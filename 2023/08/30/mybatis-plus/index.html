
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>mybatis-plus | 竹客</title>
        <meta name="author" content="Bamboo" />
        <meta name="description" content="所有随风而逝的都是属于昨天的，所有历经风雨留下来的才是面向未来的。" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>竹客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;竹客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div class="article">
    <div>
        <h1>mybatis-plus</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/8/30
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>[TOC]</p>
<h1 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h1><h2 id="1-1-添加依赖"><a href="#1-1-添加依赖" class="headerlink" title="1.1 添加依赖"></a>1.1 添加依赖</h2><pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.5.3&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h2 id="1-2-设置yml"><a href="#1-2-设置yml" class="headerlink" title="1.2 设置yml"></a>1.2 设置yml</h2><pre><code class="yml">server:
  port: 80
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf8&amp;useSSL=false
    username: root
    password: root
</code></pre>
<h2 id="1-3-添加mapper"><a href="#1-3-添加mapper" class="headerlink" title="1.3 添加mapper"></a>1.3 添加mapper</h2><pre><code class="java">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
&#125;
</code></pre>
<ul>
<li>此时默认无法生效</li>
<li>下列两种方法任取其一即可</li>
</ul>
<h3 id="1-3-1-生效方法一：-Mapper"><a href="#1-3-1-生效方法一：-Mapper" class="headerlink" title="1.3.1 生效方法一：@Mapper"></a>1.3.1 生效方法一：@Mapper</h3><pre><code class="java">@Mapper
//@Repository
public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
&#125;
</code></pre>
<h3 id="1-3-2-生效方法二：-MapperScan"><a href="#1-3-2-生效方法二：-MapperScan" class="headerlink" title="1.3.2 生效方法二：@MapperScan"></a>1.3.2 生效方法二：@MapperScan</h3><pre><code class="java">@MapperScan(basePackages = &quot;com.bamboo.boot.mapper&quot;)
@SpringBootApplication
public class MainApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(MainApplication.class, args);
    &#125;

&#125;
</code></pre>
<ul>
<li>可选操作：在@MapperScan注解后，为了可读性，可以在mapper接口中添加注解@Repository</li>
</ul>
<h2 id="1-4-应用"><a href="#1-4-应用" class="headerlink" title="1.4 应用"></a>1.4 应用</h2><pre><code class="java">@SpringBootTest
class MainApplicationTests &#123;

    @Autowired
    private UserMapper userMapper;

    @Test
    void contextLoads() &#123;
        userMapper.selectList(null).forEach(System.out::println);
    &#125;

&#125;
</code></pre>
<h2 id="1-5-添加日志"><a href="#1-5-添加日志" class="headerlink" title="1.5 添加日志"></a>1.5 添加日志</h2><pre><code class="yml">mybatis-plus:
  configuration:
    # 配置mybatis日志
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
</code></pre>
<h1 id="二、CRUD"><a href="#二、CRUD" class="headerlink" title="二、CRUD"></a>二、CRUD</h1><h2 id="2-1-BaseMapper"><a href="#2-1-BaseMapper" class="headerlink" title="2.1 BaseMapper"></a>2.1 BaseMapper</h2><p>MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，可以直接使用。</p>
<pre><code class="java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.baomidou.mybatisplus.core.mapper;

import com.baomidou.mybatisplus.core.conditions.Wrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import java.io.Serializable;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.exceptions.TooManyResultsException;

/**
 * Mapper 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能
 * &lt;p&gt;这个 Mapper 支持 id 泛型&lt;/p&gt;
 *
 * @author hubin
 * @since 2016-01-23
 */
public interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt; &#123;

    /**
     * 插入一条记录
     *
     * @param entity 实体对象
     */
    int insert(T entity);

    /**
     * 根据 ID 删除
     *
     * @param id 主键ID
     */
    int deleteById(Serializable id);

    /**
     * 根据实体(ID)删除
     *
     * @param entity 实体对象
     * @since 3.4.4
     */
    int deleteById(T entity);

    /**
     * 根据 columnMap 条件，删除记录
     *
     * @param columnMap 表字段 map 对象
     */
    int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);

    /**
     * 根据 entity 条件，删除记录
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）
     */
    int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);

    /**
     * 删除（根据ID或实体 批量删除）
     *
     * @param idList 主键ID列表或实体列表(不能为 null 以及 empty)
     */
    int deleteBatchIds(@Param(Constants.COLL) Collection&lt;?&gt; idList);

    /**
     * 根据 ID 修改
     *
     * @param entity 实体对象
     */
    int updateById(@Param(Constants.ENTITY) T entity);

    /**
     * 根据 whereEntity 条件，更新记录
     *
     * @param entity        实体对象 (set 条件值,可以为 null)
     * @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）
     */
    int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; updateWrapper);

    /**
     * 根据 ID 查询
     *
     * @param id 主键ID
     */
    T selectById(Serializable id);

    /**
     * 查询（根据ID 批量查询）
     *
     * @param idList 主键ID列表(不能为 null 以及 empty)
     */
    List&lt;T&gt; selectBatchIds(@Param(Constants.COLL) Collection&lt;? extends Serializable&gt; idList);

    /**
     * 查询（根据 columnMap 条件）
     *
     * @param columnMap 表字段 map 对象
     */
    List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);

    /**
     * 根据 entity 条件，查询一条记录
     * &lt;p&gt;查询一条记录，例如 qw.last(&quot;limit 1&quot;) 限制取一条记录, 注意：多条数据会报异常&lt;/p&gt;
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    default T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper) &#123;
        List&lt;T&gt; list = this.selectList(queryWrapper);
        // 抄自 DefaultSqlSession#selectOne
        if (list.size() == 1) &#123;
            return list.get(0);
        &#125; else if (list.size() &gt; 1) &#123;
            throw new TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());
        &#125; else &#123;
            return null;
        &#125;
    &#125;

    /**
     * 根据 Wrapper 条件，判断是否存在记录
     *
     * @param queryWrapper 实体对象封装操作类
     * @return 是否存在记录
     */
    default boolean exists(Wrapper&lt;T&gt; queryWrapper) &#123;
        Long count = this.selectCount(queryWrapper);
        return null != count &amp;&amp; count &gt; 0;
    &#125;

    /**
     * 根据 Wrapper 条件，查询总记录数
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    Long selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);

    /**
     * 根据 entity 条件，查询全部记录
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);

    /**
     * 根据 Wrapper 条件，查询全部记录
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);

    /**
     * 根据 Wrapper 条件，查询全部记录
     * &lt;p&gt;注意： 只返回第一个字段的值&lt;/p&gt;
     *
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);

    /**
     * 根据 entity 条件，查询全部记录（并翻页）
     *
     * @param page         分页查询条件（可以为 RowBounds.DEFAULT）
     * @param queryWrapper 实体对象封装操作类（可以为 null）
     */
    &lt;P extends IPage&lt;T&gt;&gt; P selectPage(P page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);

    /**
     * 根据 Wrapper 条件，查询全部记录（并翻页）
     *
     * @param page         分页查询条件
     * @param queryWrapper 实体对象封装操作类
     */
    &lt;P extends IPage&lt;Map&lt;String, Object&gt;&gt;&gt; P selectMapsPage(P page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);
&#125;
</code></pre>
<h2 id="2-2-插入"><a href="#2-2-插入" class="headerlink" title="2.2 插入"></a>2.2 插入</h2><pre><code class="java">    @Test
    public void testInsert() &#123;
        User user = new User(null, &quot;张三&quot;, 23, &quot;zhangsan@atguigu.com&quot;);
        //INSERT INTO user ( id, name, age, email ) VALUES ( ?, ?, ?, ? )
        int result = userMapper.insert(user);
        System.out.println(&quot;受影响行数：&quot; + result);
        //1475754982694199298
        System.out.println(&quot;id自动获取：&quot; + user.getId());
    &#125;
</code></pre>
<blockquote>
<p>最终执行的结果，所获取的id为1475754982694199298</p>
<p>这是因为MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</p>
</blockquote>
<h2 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h2><h3 id="2-3-1-通过id删除记录"><a href="#2-3-1-通过id删除记录" class="headerlink" title="2.3.1 通过id删除记录"></a>2.3.1 通过id删除记录</h3><pre><code class="java">    @Test
    public void testDeleteById() &#123;
        //通过id删除用户信息
        //DELETE FROM user WHERE id=?
        int result = userMapper.deleteById(1475754982694199298L);
        System.out.println(&quot;受影响行数：&quot; + result);
    &#125;
</code></pre>
<h3 id="2-3-2-通过id批量删除记录"><a href="#2-3-2-通过id批量删除记录" class="headerlink" title="2.3.2 通过id批量删除记录"></a>2.3.2 通过id批量删除记录</h3><pre><code class="java">    @Test
    public void testDeleteBatchIds()&#123;
        //通过多个id批量删除
        //DELETE FROM user WHERE id IN ( ? , ? , ? )
        List&lt;Long&gt; idList = Arrays.asList(1L, 2L, 3L);
        int result = userMapper.deleteBatchIds(idList);
        System.out.println(&quot;受影响行数：&quot;+result);
    &#125;
</code></pre>
<h3 id="2-3-3-通过map条件删除记录"><a href="#2-3-3-通过map条件删除记录" class="headerlink" title="2.3.3 通过map条件删除记录"></a>2.3.3 通过map条件删除记录</h3><pre><code class="java">    @Test
    public void testDeleteByMap()&#123;
        //根据map集合中所设置的条件删除记录
        //DELETE FROM user WHERE name = ? AND age = ?
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;age&quot;, 23);
        map.put(&quot;name&quot;, &quot;张三&quot;);
        int result = userMapper.deleteByMap(map);
        System.out.println(&quot;受影响行数：&quot;+result);
    &#125;
</code></pre>
<h2 id="2-4-修改"><a href="#2-4-修改" class="headerlink" title="2.4 修改"></a>2.4 修改</h2><pre><code class="java">    @Test
    public void testUpdateById() &#123;
        User user = new User(4L, &quot;admin&quot;, 22, null);
        //UPDATE user SET name=?, age=? WHERE id=?
        int result = userMapper.updateById(user);
        System.out.println(&quot;受影响行数：&quot; + result);
    &#125;
</code></pre>
<h2 id="2-5-查询"><a href="#2-5-查询" class="headerlink" title="2.5 查询"></a>2.5 查询</h2><h3 id="2-5-1-根据id查询用户信息"><a href="#2-5-1-根据id查询用户信息" class="headerlink" title="2.5.1 根据id查询用户信息"></a>2.5.1 根据id查询用户信息</h3><pre><code class="java">    @Test
    public void testSelectById() &#123;
        //根据id查询用户信息
        //SELECT id,name,age,email FROM user WHERE id=?
        User user = userMapper.selectById(4L);
        System.out.println(user);
    &#125;
</code></pre>
<h3 id="2-5-2-根据多个id查询多个用户信息"><a href="#2-5-2-根据多个id查询多个用户信息" class="headerlink" title="2.5.2 根据多个id查询多个用户信息"></a>2.5.2 根据多个id查询多个用户信息</h3><pre><code class="java">    @Test
    public void testSelectBatchIds() &#123;
        //根据多个id查询多个用户信息
        //SELECT id,name,age,email FROM user WHERE id IN ( ? , ? )
        List&lt;Long&gt; idList = Arrays.asList(4L, 5L);
        List&lt;User&gt; list = userMapper.selectBatchIds(idList);
        list.forEach(System.out::println);
    &#125;
</code></pre>
<h3 id="2-5-3-通过map条件查询用户信息"><a href="#2-5-3-通过map条件查询用户信息" class="headerlink" title="2.5.3 通过map条件查询用户信息"></a>2.5.3 通过map条件查询用户信息</h3><pre><code class="java">    @Test
    public void testSelectByMap() &#123;
        //通过map条件查询用户信息
        //SELECT id,name,age,email FROM user WHERE name = ? AND age = ?
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;age&quot;, 22);
        map.put(&quot;name&quot;, &quot;admin&quot;);
        List&lt;User&gt; list = userMapper.selectByMap(map);
        list.forEach(System.out::println);
    &#125;
</code></pre>
<h3 id="2-5-4-查询所有数据"><a href="#2-5-4-查询所有数据" class="headerlink" title="2.5.4 查询所有数据"></a>2.5.4 查询所有数据</h3><pre><code class="java">    @Test
    public void testSelectList() &#123;
        //查询所有用户信息
        //SELECT id,name,age,email FROM user
        List&lt;User&gt; list = userMapper.selectList(null);
        list.forEach(System.out::println);
    &#125;
</code></pre>
<h2 id="2-6-通用Service"><a href="#2-6-通用Service" class="headerlink" title="2.6 通用Service"></a>2.6 通用Service</h2><blockquote>
<p>说明：</p>
<ul>
<li>通用 Service CRUD 封装IService接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 Mapper 层避免混淆</li>
<li>泛型 <code>T</code> 为任意实体对象</li>
<li>建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承<code>Mybatis-Plus</code>提供的基类</li>
</ul>
</blockquote>
<h3 id="2-6-1-IService"><a href="#2-6-1-IService" class="headerlink" title="2.6.1 IService"></a>2.6.1 IService</h3><ul>
<li>MyBatis-Plus中有一个接口 IService和其实现类 ServiceImpl，封装了常见的业务层逻辑</li>
<li>详情查看源码IService和ServiceImpl</li>
</ul>
<h4 id="①-IService源码"><a href="#①-IService源码" class="headerlink" title="① IService源码"></a>① IService源码</h4><pre><code class="java">package com.baomidou.mybatisplus.extension.service;

/**
 * 顶级 Service
 *
 * @author hubin
 * @since 2018-06-23
 */
public interface IService&lt;T&gt; &#123;

    /**
     * 默认批次提交数量
     */
    int DEFAULT_BATCH_SIZE = 1000;

    /**
     * 插入一条记录（选择字段，策略插入）
     *
     * @param entity 实体对象
     */
    default boolean save(T entity) &#123;
        return SqlHelper.retBool(getBaseMapper().insert(entity));
    &#125;

    /**
     * 插入（批量）
     *
     * @param entityList 实体对象集合
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean saveBatch(Collection&lt;T&gt; entityList) &#123;
        return saveBatch(entityList, DEFAULT_BATCH_SIZE);
    &#125;

    /**
     * 插入（批量）
     *
     * @param entityList 实体对象集合
     * @param batchSize  插入批次数量
     */
    boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize);

    /**
     * 批量修改插入
     *
     * @param entityList 实体对象集合
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList) &#123;
        return saveOrUpdateBatch(entityList, DEFAULT_BATCH_SIZE);
    &#125;

    /**
     * 批量修改插入
     *
     * @param entityList 实体对象集合
     * @param batchSize  每次的数量
     */
    boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList, int batchSize);

    /**
     * 根据 ID 删除
     *
     * @param id 主键ID
     */
    default boolean removeById(Serializable id) &#123;
        return SqlHelper.retBool(getBaseMapper().deleteById(id));
    &#125;

    /**
     * 根据 ID 删除
     *
     * @param id      主键(类型必须与实体类型字段保持一致)
     * @param useFill 是否启用填充(为true的情况,会将入参转换实体进行delete删除)
     * @return 删除结果
     * @since 3.5.0
     */
    default boolean removeById(Serializable id, boolean useFill) &#123;
        throw new UnsupportedOperationException(&quot;不支持的方法!&quot;);
    &#125;

    /**
     * 根据实体(ID)删除
     *
     * @param entity 实体
     * @since 3.4.4
     */
    default boolean removeById(T entity) &#123;
        return SqlHelper.retBool(getBaseMapper().deleteById(entity));
    &#125;

    /**
     * 根据 columnMap 条件，删除记录
     *
     * @param columnMap 表字段 map 对象
     */
    default boolean removeByMap(Map&lt;String, Object&gt; columnMap) &#123;
        Assert.notEmpty(columnMap, &quot;error: columnMap must not be empty&quot;);
        return SqlHelper.retBool(getBaseMapper().deleteByMap(columnMap));
    &#125;

    /**
     * 根据 entity 条件，删除记录
     *
     * @param queryWrapper 实体包装类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     */
    default boolean remove(Wrapper&lt;T&gt; queryWrapper) &#123;
        return SqlHelper.retBool(getBaseMapper().delete(queryWrapper));
    &#125;

    /**
     * 删除（根据ID 批量删除）
     *
     * @param list 主键ID或实体列表
     */
    default boolean removeByIds(Collection&lt;?&gt; list) &#123;
        if (CollectionUtils.isEmpty(list)) &#123;
            return false;
        &#125;
        return SqlHelper.retBool(getBaseMapper().deleteBatchIds(list));
    &#125;

    /**
     * 批量删除
     *
     * @param list    主键ID或实体列表
     * @param useFill 是否填充(为true的情况,会将入参转换实体进行delete删除)
     * @return 删除结果
     * @since 3.5.0
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean removeByIds(Collection&lt;?&gt; list, boolean useFill) &#123;
        if (CollectionUtils.isEmpty(list)) &#123;
            return false;
        &#125;
        if (useFill) &#123;
            return removeBatchByIds(list, true);
        &#125;
        return SqlHelper.retBool(getBaseMapper().deleteBatchIds(list));
    &#125;

    /**
     * 批量删除(jdbc批量提交)
     *
     * @param list 主键ID或实体列表(主键ID类型必须与实体类型字段保持一致)
     * @return 删除结果
     * @since 3.5.0
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean removeBatchByIds(Collection&lt;?&gt; list) &#123;
        return removeBatchByIds(list, DEFAULT_BATCH_SIZE);
    &#125;

    /**
     * 批量删除(jdbc批量提交)
     *
     * @param list    主键ID或实体列表(主键ID类型必须与实体类型字段保持一致)
     * @param useFill 是否启用填充(为true的情况,会将入参转换实体进行delete删除)
     * @return 删除结果
     * @since 3.5.0
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean removeBatchByIds(Collection&lt;?&gt; list, boolean useFill) &#123;
        return removeBatchByIds(list, DEFAULT_BATCH_SIZE, useFill);
    &#125;

    /**
     * 批量删除(jdbc批量提交)
     *
     * @param list      主键ID或实体列表
     * @param batchSize 批次大小
     * @return 删除结果
     * @since 3.5.0
     */
    default boolean removeBatchByIds(Collection&lt;?&gt; list, int batchSize) &#123;
        throw new UnsupportedOperationException(&quot;不支持的方法!&quot;);
    &#125;

    /**
     * 批量删除(jdbc批量提交)
     *
     * @param list      主键ID或实体列表
     * @param batchSize 批次大小
     * @param useFill   是否启用填充(为true的情况,会将入参转换实体进行delete删除)
     * @return 删除结果
     * @since 3.5.0
     */
    default boolean removeBatchByIds(Collection&lt;?&gt; list, int batchSize, boolean useFill) &#123;
        throw new UnsupportedOperationException(&quot;不支持的方法!&quot;);
    &#125;

    /**
     * 根据 ID 选择修改
     *
     * @param entity 实体对象
     */
    default boolean updateById(T entity) &#123;
        return SqlHelper.retBool(getBaseMapper().updateById(entity));
    &#125;

    /**
     * 根据 UpdateWrapper 条件，更新记录 需要设置sqlset
     *
     * @param updateWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper&#125;
     */
    default boolean update(Wrapper&lt;T&gt; updateWrapper) &#123;
        return update(null, updateWrapper);
    &#125;

    /**
     * 根据 whereEntity 条件，更新记录
     *
     * @param entity        实体对象
     * @param updateWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper&#125;
     */
    default boolean update(T entity, Wrapper&lt;T&gt; updateWrapper) &#123;
        return SqlHelper.retBool(getBaseMapper().update(entity, updateWrapper));
    &#125;

    /**
     * 根据ID 批量更新
     *
     * @param entityList 实体对象集合
     */
    @Transactional(rollbackFor = Exception.class)
    default boolean updateBatchById(Collection&lt;T&gt; entityList) &#123;
        return updateBatchById(entityList, DEFAULT_BATCH_SIZE);
    &#125;

    /**
     * 根据ID 批量更新
     *
     * @param entityList 实体对象集合
     * @param batchSize  更新批次数量
     */
    boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize);

    /**
     * TableId 注解存在更新记录，否插入一条记录
     *
     * @param entity 实体对象
     */
    boolean saveOrUpdate(T entity);

    /**
     * 根据 ID 查询
     *
     * @param id 主键ID
     */
    default T getById(Serializable id) &#123;
        return getBaseMapper().selectById(id);
    &#125;

    /**
     * 查询（根据ID 批量查询）
     *
     * @param idList 主键ID列表
     */
    default List&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList) &#123;
        return getBaseMapper().selectBatchIds(idList);
    &#125;

    /**
     * 查询（根据 columnMap 条件）
     *
     * @param columnMap 表字段 map 对象
     */
    default List&lt;T&gt; listByMap(Map&lt;String, Object&gt; columnMap) &#123;
        return getBaseMapper().selectByMap(columnMap);
    &#125;

    /**
     * 根据 Wrapper，查询一条记录 &lt;br/&gt;
     * &lt;p&gt;结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)&lt;/p&gt;
     *
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     */
    default T getOne(Wrapper&lt;T&gt; queryWrapper) &#123;
        return getOne(queryWrapper, true);
    &#125;

    /**
     * 根据 Wrapper，查询一条记录
     *
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     * @param throwEx      有多个 result 是否抛出异常
     */
    T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);

    /**
     * 根据 Wrapper，查询一条记录
     *
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     */
    Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper);

    /**
     * 根据 Wrapper，查询一条记录
     *
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     * @param mapper       转换函数
     */
    &lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);

    /**
     * 查询总记录数
     *
     * @see Wrappers#emptyWrapper()
     */
    default long count() &#123;
        return count(Wrappers.emptyWrapper());
    &#125;

    /**
     * 根据 Wrapper 条件，查询总记录数
     *
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     */
    default long count(Wrapper&lt;T&gt; queryWrapper) &#123;
        return SqlHelper.retCount(getBaseMapper().selectCount(queryWrapper));
    &#125;

    /**
     * 查询列表
     *
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     */
    default List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper) &#123;
        return getBaseMapper().selectList(queryWrapper);
    &#125;

    /**
     * 查询所有
     *
     * @see Wrappers#emptyWrapper()
     */
    default List&lt;T&gt; list() &#123;
        return list(Wrappers.emptyWrapper());
    &#125;

    /**
     * 翻页查询
     *
     * @param page         翻页对象
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     */
    default &lt;E extends IPage&lt;T&gt;&gt; E page(E page, Wrapper&lt;T&gt; queryWrapper) &#123;
        return getBaseMapper().selectPage(page, queryWrapper);
    &#125;

    /**
     * 无条件翻页查询
     *
     * @param page 翻页对象
     * @see Wrappers#emptyWrapper()
     */
    default &lt;E extends IPage&lt;T&gt;&gt; E page(E page) &#123;
        return page(page, Wrappers.emptyWrapper());
    &#125;

    /**
     * 查询列表
     *
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     */
    default List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper) &#123;
        return getBaseMapper().selectMaps(queryWrapper);
    &#125;

    /**
     * 查询所有列表
     *
     * @see Wrappers#emptyWrapper()
     */
    default List&lt;Map&lt;String, Object&gt;&gt; listMaps() &#123;
        return listMaps(Wrappers.emptyWrapper());
    &#125;

    /**
     * 查询全部记录
     */
    default List&lt;Object&gt; listObjs() &#123;
        return listObjs(Function.identity());
    &#125;

    /**
     * 查询全部记录
     *
     * @param mapper 转换函数
     */
    default &lt;V&gt; List&lt;V&gt; listObjs(Function&lt;? super Object, V&gt; mapper) &#123;
        return listObjs(Wrappers.emptyWrapper(), mapper);
    &#125;

    /**
     * 根据 Wrapper 条件，查询全部记录
     *
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     */
    default List&lt;Object&gt; listObjs(Wrapper&lt;T&gt; queryWrapper) &#123;
        return listObjs(queryWrapper, Function.identity());
    &#125;

    /**
     * 根据 Wrapper 条件，查询全部记录
     *
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     * @param mapper       转换函数
     */
    default &lt;V&gt; List&lt;V&gt; listObjs(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper) &#123;
        return getBaseMapper().selectObjs(queryWrapper).stream().filter(Objects::nonNull).map(mapper).collect(Collectors.toList());
    &#125;

    /**
     * 翻页查询
     *
     * @param page         翻页对象
     * @param queryWrapper 实体对象封装操作类 &#123;@link com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;
     */
    default &lt;E extends IPage&lt;Map&lt;String, Object&gt;&gt;&gt; E pageMaps(E page, Wrapper&lt;T&gt; queryWrapper) &#123;
        return getBaseMapper().selectMapsPage(page, queryWrapper);
    &#125;

    /**
     * 无条件翻页查询
     *
     * @param page 翻页对象
     * @see Wrappers#emptyWrapper()
     */
    default &lt;E extends IPage&lt;Map&lt;String, Object&gt;&gt;&gt; E pageMaps(E page) &#123;
        return pageMaps(page, Wrappers.emptyWrapper());
    &#125;

    /**
     * 获取对应 entity 的 BaseMapper
     *
     * @return BaseMapper
     */
    BaseMapper&lt;T&gt; getBaseMapper();

    /**
     * 获取 entity 的 class
     *
     * @return &#123;@link Class&lt;T&gt;&#125;
     */
    Class&lt;T&gt; getEntityClass();

    /**
     * 以下的方法使用介绍:
     *
     * 一. 名称介绍
     * 1. 方法名带有 query 的为对数据的查询操作, 方法名带有 update 的为对数据的修改操作
     * 2. 方法名带有 lambda 的为内部方法入参 column 支持函数式的
     * 二. 支持介绍
     *
     * 1. 方法名带有 query 的支持以 &#123;@link ChainQuery&#125; 内部的方法名结尾进行数据查询操作
     * 2. 方法名带有 update 的支持以 &#123;@link ChainUpdate&#125; 内部的方法名为结尾进行数据修改操作
     *
     * 三. 使用示例,只用不带 lambda 的方法各展示一个例子,其他类推
     * 1. 根据条件获取一条数据: `query().eq(&quot;column&quot;, value).one()`
     * 2. 根据条件删除一条数据: `update().eq(&quot;column&quot;, value).remove()`
     *
     */

    /**
     * 链式查询 普通
     *
     * @return QueryWrapper 的包装类
     */
    default QueryChainWrapper&lt;T&gt; query() &#123;
        return ChainWrappers.queryChain(getBaseMapper());
    &#125;

    /**
     * 链式查询 lambda 式
     * &lt;p&gt;注意：不支持 Kotlin &lt;/p&gt;
     *
     * @return LambdaQueryWrapper 的包装类
     */
    default LambdaQueryChainWrapper&lt;T&gt; lambdaQuery() &#123;
        return ChainWrappers.lambdaQueryChain(getBaseMapper(), getEntityClass());
    &#125;

    /**
     * 链式查询 lambda 式
     * &lt;p&gt;注意：不支持 Kotlin &lt;/p&gt;
     *
     * @param entity 实体对象
     * @return LambdaQueryWrapper 的包装类
     */
    default LambdaQueryChainWrapper&lt;T&gt; lambdaQuery(T entity) &#123;
        return ChainWrappers.lambdaQueryChain(getBaseMapper(), entity);
    &#125;

    /**
     * 链式查询 lambda 式
     * kotlin 使用
     *
     * @return KtQueryWrapper 的包装类
     */
    default KtQueryChainWrapper&lt;T&gt; ktQuery() &#123;
        return ChainWrappers.ktQueryChain(getBaseMapper(), getEntityClass());
    &#125;

    /**
     * 链式查询 lambda 式
     * kotlin 使用
     *
     * @return KtQueryWrapper 的包装类
     */
    default KtUpdateChainWrapper&lt;T&gt; ktUpdate() &#123;
        return ChainWrappers.ktUpdateChain(getBaseMapper(), getEntityClass());
    &#125;

    /**
     * 链式更改 普通
     *
     * @return UpdateWrapper 的包装类
     */
    default UpdateChainWrapper&lt;T&gt; update() &#123;
        return ChainWrappers.updateChain(getBaseMapper());
    &#125;

    /**
     * 链式更改 lambda 式
     * &lt;p&gt;注意：不支持 Kotlin &lt;/p&gt;
     *
     * @return LambdaUpdateWrapper 的包装类
     */
    default LambdaUpdateChainWrapper&lt;T&gt; lambdaUpdate() &#123;
        return ChainWrappers.lambdaUpdateChain(getBaseMapper());
    &#125;

    /**
     * &lt;p&gt;
     * 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法
     * 此次修改主要是减少了此项业务代码的代码量（存在性验证之后的saveOrUpdate操作）
     * &lt;/p&gt;
     *
     * @param entity 实体对象
     */
    default boolean saveOrUpdate(T entity, Wrapper&lt;T&gt; updateWrapper) &#123;
        return update(entity, updateWrapper) || saveOrUpdate(entity);
    &#125;
&#125;
</code></pre>
<h4 id="②-ServiceImpl源码"><a href="#②-ServiceImpl源码" class="headerlink" title="② ServiceImpl源码"></a>② ServiceImpl源码</h4><pre><code class="java">package com.baomidou.mybatisplus.extension.service.impl;

/**
 * IService 实现类（ 泛型：M 是 mapper 对象，T 是实体 ）
 *
 * @author hubin
 * @since 2018-06-23
 */
@SuppressWarnings(&quot;unchecked&quot;)
public class ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; implements IService&lt;T&gt; &#123;

    protected Log log = LogFactory.getLog(getClass());

    @Autowired
    protected M baseMapper;

    @Override
    public M getBaseMapper() &#123;
        return baseMapper;
    &#125;

    protected Class&lt;T&gt; entityClass = currentModelClass();

    @Override
    public Class&lt;T&gt; getEntityClass() &#123;
        return entityClass;
    &#125;

    protected Class&lt;M&gt; mapperClass = currentMapperClass();

    /**
     * 判断数据库操作是否成功
     *
     * @param result 数据库操作返回影响条数
     * @return boolean
     * @deprecated 3.3.1
     */
    @Deprecated
    protected boolean retBool(Integer result) &#123;
        return SqlHelper.retBool(result);
    &#125;

    protected Class&lt;M&gt; currentMapperClass() &#123;
        return (Class&lt;M&gt;) ReflectionKit.getSuperClassGenericType(this.getClass(), ServiceImpl.class, 0);
    &#125;

    protected Class&lt;T&gt; currentModelClass() &#123;
        return (Class&lt;T&gt;) ReflectionKit.getSuperClassGenericType(this.getClass(), ServiceImpl.class, 1);
    &#125;


    /**
     * 批量操作 SqlSession
     *
     * @deprecated 3.3.0
     */
    @Deprecated
    protected SqlSession sqlSessionBatch() &#123;
        return SqlHelper.sqlSessionBatch(entityClass);
    &#125;

    /**
     * 释放sqlSession
     *
     * @param sqlSession session
     * @deprecated 3.3.0
     */
    @Deprecated
    protected void closeSqlSession(SqlSession sqlSession) &#123;
        SqlSessionUtils.closeSqlSession(sqlSession, GlobalConfigUtils.currentSessionFactory(entityClass));
    &#125;

    /**
     * 获取 SqlStatement
     *
     * @param sqlMethod ignore
     * @return ignore
     * @see #getSqlStatement(SqlMethod)
     * @deprecated 3.4.0
     */
    @Deprecated
    protected String sqlStatement(SqlMethod sqlMethod) &#123;
        return SqlHelper.table(entityClass).getSqlStatement(sqlMethod.getMethod());
    &#125;

    /**
     * 批量插入
     *
     * @param entityList ignore
     * @param batchSize  ignore
     * @return ignore
     */
    @Transactional(rollbackFor = Exception.class)
    @Override
    public boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize) &#123;
        String sqlStatement = getSqlStatement(SqlMethod.INSERT_ONE);
        return executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));
    &#125;

    /**
     * 获取mapperStatementId
     *
     * @param sqlMethod 方法名
     * @return 命名id
     * @since 3.4.0
     */
    protected String getSqlStatement(SqlMethod sqlMethod) &#123;
        return SqlHelper.getSqlStatement(mapperClass, sqlMethod);
    &#125;

    /**
     * TableId 注解存在更新记录，否插入一条记录
     *
     * @param entity 实体对象
     * @return boolean
     */
    @Transactional(rollbackFor = Exception.class)
    @Override
    public boolean saveOrUpdate(T entity) &#123;
        if (null != entity) &#123;
            TableInfo tableInfo = TableInfoHelper.getTableInfo(this.entityClass);
            Assert.notNull(tableInfo, &quot;error: can not execute. because can not find cache of TableInfo for entity!&quot;);
            String keyProperty = tableInfo.getKeyProperty();
            Assert.notEmpty(keyProperty, &quot;error: can not execute. because can not find column for id from entity!&quot;);
            Object idVal = tableInfo.getPropertyValue(entity, tableInfo.getKeyProperty());
            return StringUtils.checkValNull(idVal) || Objects.isNull(getById((Serializable) idVal)) ? save(entity) : updateById(entity);
        &#125;
        return false;
    &#125;

    @Transactional(rollbackFor = Exception.class)
    @Override
    public boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList, int batchSize) &#123;
        TableInfo tableInfo = TableInfoHelper.getTableInfo(entityClass);
        Assert.notNull(tableInfo, &quot;error: can not execute. because can not find cache of TableInfo for entity!&quot;);
        String keyProperty = tableInfo.getKeyProperty();
        Assert.notEmpty(keyProperty, &quot;error: can not execute. because can not find column for id from entity!&quot;);
        return SqlHelper.saveOrUpdateBatch(this.entityClass, this.mapperClass, this.log, entityList, batchSize, (sqlSession, entity) -&gt; &#123;
            Object idVal = tableInfo.getPropertyValue(entity, keyProperty);
            return StringUtils.checkValNull(idVal)
                || CollectionUtils.isEmpty(sqlSession.selectList(getSqlStatement(SqlMethod.SELECT_BY_ID), entity));
        &#125;, (sqlSession, entity) -&gt; &#123;
            MapperMethod.ParamMap&lt;T&gt; param = new MapperMethod.ParamMap&lt;&gt;();
            param.put(Constants.ENTITY, entity);
            sqlSession.update(getSqlStatement(SqlMethod.UPDATE_BY_ID), param);
        &#125;);
    &#125;

    @Transactional(rollbackFor = Exception.class)
    @Override
    public boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize) &#123;
        String sqlStatement = getSqlStatement(SqlMethod.UPDATE_BY_ID);
        return executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; &#123;
            MapperMethod.ParamMap&lt;T&gt; param = new MapperMethod.ParamMap&lt;&gt;();
            param.put(Constants.ENTITY, entity);
            sqlSession.update(sqlStatement, param);
        &#125;);
    &#125;

    @Override
    public T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx) &#123;
        if (throwEx) &#123;
            return baseMapper.selectOne(queryWrapper);
        &#125;
        return SqlHelper.getObject(log, baseMapper.selectList(queryWrapper));
    &#125;

    @Override
    public Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper) &#123;
        return SqlHelper.getObject(log, baseMapper.selectMaps(queryWrapper));
    &#125;

    @Override
    public &lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper) &#123;
        return SqlHelper.getObject(log, listObjs(queryWrapper, mapper));
    &#125;

    /**
     * 执行批量操作
     *
     * @param consumer consumer
     * @since 3.3.0
     * @deprecated 3.3.1 后面我打算移除掉 &#123;@link #executeBatch(Collection, int, BiConsumer)&#125; &#125;.
     */
    @Deprecated
    protected boolean executeBatch(Consumer&lt;SqlSession&gt; consumer) &#123;
        return SqlHelper.executeBatch(this.entityClass, this.log, consumer);
    &#125;

    /**
     * 执行批量操作
     *
     * @param list      数据集合
     * @param batchSize 批量大小
     * @param consumer  执行方法
     * @param &lt;E&gt;       泛型
     * @return 操作结果
     * @since 3.3.1
     */
    protected &lt;E&gt; boolean executeBatch(Collection&lt;E&gt; list, int batchSize, BiConsumer&lt;SqlSession, E&gt; consumer) &#123;
        return SqlHelper.executeBatch(this.entityClass, this.log, list, batchSize, consumer);
    &#125;

    /**
     * 执行批量操作（默认批次提交数量&#123;@link IService#DEFAULT_BATCH_SIZE&#125;）
     *
     * @param list     数据集合
     * @param consumer 执行方法
     * @param &lt;E&gt;      泛型
     * @return 操作结果
     * @since 3.3.1
     */
    protected &lt;E&gt; boolean executeBatch(Collection&lt;E&gt; list, BiConsumer&lt;SqlSession, E&gt; consumer) &#123;
        return executeBatch(list, DEFAULT_BATCH_SIZE, consumer);
    &#125;

    @Override
    public boolean removeById(Serializable id) &#123;
        TableInfo tableInfo = TableInfoHelper.getTableInfo(getEntityClass());
        if (tableInfo.isWithLogicDelete() &amp;&amp; tableInfo.isWithUpdateFill()) &#123;
            return removeById(id, true);
        &#125;
        return SqlHelper.retBool(getBaseMapper().deleteById(id));
    &#125;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public boolean removeByIds(Collection&lt;?&gt; list) &#123;
        if (CollectionUtils.isEmpty(list)) &#123;
            return false;
        &#125;
        TableInfo tableInfo = TableInfoHelper.getTableInfo(getEntityClass());
        if (tableInfo.isWithLogicDelete() &amp;&amp; tableInfo.isWithUpdateFill()) &#123;
            return removeBatchByIds(list, true);
        &#125;
        return SqlHelper.retBool(getBaseMapper().deleteBatchIds(list));
    &#125;

    @Override
    public boolean removeById(Serializable id, boolean useFill) &#123;
        TableInfo tableInfo = TableInfoHelper.getTableInfo(entityClass);
        if (useFill &amp;&amp; tableInfo.isWithLogicDelete()) &#123;
            if (!entityClass.isAssignableFrom(id.getClass())) &#123;
                T instance = tableInfo.newInstance();
                tableInfo.setPropertyValue(instance, tableInfo.getKeyProperty(), id);
                return removeById(instance);
            &#125;
        &#125;
        return SqlHelper.retBool(getBaseMapper().deleteById(id));
    &#125;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public boolean removeBatchByIds(Collection&lt;?&gt; list, int batchSize) &#123;
        TableInfo tableInfo = TableInfoHelper.getTableInfo(entityClass);
        return removeBatchByIds(list, batchSize, tableInfo.isWithLogicDelete() &amp;&amp; tableInfo.isWithUpdateFill());
    &#125;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public boolean removeBatchByIds(Collection&lt;?&gt; list, int batchSize, boolean useFill) &#123;
        String sqlStatement = getSqlStatement(SqlMethod.DELETE_BY_ID);
        TableInfo tableInfo = TableInfoHelper.getTableInfo(entityClass);
        return executeBatch(list, batchSize, (sqlSession, e) -&gt; &#123;
            if (useFill &amp;&amp; tableInfo.isWithLogicDelete()) &#123;
                if (entityClass.isAssignableFrom(e.getClass())) &#123;
                    sqlSession.update(sqlStatement, e);
                &#125; else &#123;
                    T instance = tableInfo.newInstance();
                    tableInfo.setPropertyValue(instance, tableInfo.getKeyProperty(), e);
                    sqlSession.update(sqlStatement, instance);
                &#125;
            &#125; else &#123;
                sqlSession.update(sqlStatement, e);
            &#125;
        &#125;);
    &#125;

&#125;
</code></pre>
<h3 id="2-6-2-创建Service接口和实现类"><a href="#2-6-2-创建Service接口和实现类" class="headerlink" title="2.6.2 创建Service接口和实现类"></a>2.6.2 创建Service接口和实现类</h3><pre><code class="java">public interface UserService extends IService&lt;User&gt; &#123;
&#125;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;
&#125;
</code></pre>
<h3 id="2-6-3-测试查询记录数"><a href="#2-6-3-测试查询记录数" class="headerlink" title="2.6.3 测试查询记录数"></a>2.6.3 测试查询记录数</h3><pre><code class="java">    @Autowired
    private UserService userService;
    
        @Test
    public void testGetCount()&#123;
        long count = userService.count();
        System.out.println(&quot;总记录数：&quot; + count);
    &#125;
</code></pre>
<h3 id="2-6-4-测试批量插入"><a href="#2-6-4-测试批量插入" class="headerlink" title="2.6.4 测试批量插入"></a>2.6.4 测试批量插入</h3><pre><code class="java">    @Test
    public void testSaveBatch()&#123;
        // SQL长度有限制，海量数据插入单条SQL无法实行，
        // 因此MP将批量插入放在了通用Service中实现，而不是通用Mapper
        ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) &#123;
            User user = new User();
            user.setName(&quot;ybc&quot; + i);
            user.setAge(20 + i);
            users.add(user);
        &#125;
        //SQL:INSERT INTO t_user ( username, age ) VALUES ( ?, ? )
        userService.saveBatch(users);
    &#125;
    /**
     * ==&gt;  Preparing: INSERT INTO user ( id, name, age ) VALUES ( ?, ?, ? )
     * ==&gt; Parameters: 1695218724078444545(Long), ybc0(String), 20(Integer)
     * ==&gt; Parameters: 1695218724221050882(Long), ybc1(String), 21(Integer)
     * ==&gt; Parameters: 1695218724221050883(Long), ybc2(String), 22(Integer)
     * ==&gt; Parameters: 1695218724221050884(Long), ybc3(String), 23(Integer)
     * ==&gt; Parameters: 1695218724221050885(Long), ybc4(String), 24(Integer)
     */
</code></pre>
<h1 id="三、常用注解"><a href="#三、常用注解" class="headerlink" title="三、常用注解"></a>三、常用注解</h1><h2 id="3-1-TableName"><a href="#3-1-TableName" class="headerlink" title="3.1 @TableName"></a>3.1 @TableName</h2><ul>
<li>在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了泛型User，而操作的表为user表</li>
<li>由此得出结论，MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致</li>
</ul>
<p>问题：</p>
<ul>
<li>若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？</li>
</ul>
<p>解决：</p>
<ul>
<li>方式一：通过@TableName解决问题</li>
<li>方式二：通过全局配置解决问题</li>
</ul>
<h3 id="3-1-1-TableName解决表名不一致"><a href="#3-1-1-TableName解决表名不一致" class="headerlink" title="3.1.1 @TableName解决表名不一致"></a>3.1.1 @TableName解决表名不一致</h3><pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName(&quot;tbl_user&quot;)
public class User &#123;
    private Long id;
    private String name;
    private Integer age;
    private String email;
&#125;
</code></pre>
<h3 id="3-1-2-全局配置默认表前缀"><a href="#3-1-2-全局配置默认表前缀" class="headerlink" title="3.1.2 全局配置默认表前缀"></a>3.1.2 全局配置默认表前缀</h3><ul>
<li>实体类所对应的表都有固定的前缀，例如<code>t_</code>或<code>tbl_</code></li>
<li>使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀</li>
</ul>
<pre><code class="yml">mybatis-plus:
  global-config:
    db-config:
      table-prefix: tbl_
</code></pre>
<h2 id="3-2-TableId"><a href="#3-2-TableId" class="headerlink" title="3.2 @TableId"></a>3.2 @TableId</h2><p>MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id</p>
<p>问题：</p>
<ul>
<li>若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主键列吗？</li>
</ul>
<p>解决：</p>
<ul>
<li>@TableId</li>
</ul>
<h3 id="3-2-1-TableId标识主键"><a href="#3-2-1-TableId标识主键" class="headerlink" title="3.2.1 @TableId标识主键"></a>3.2.1 @TableId标识主键</h3><pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;
    @TableId
    private Long uid;
    private String name;
    private Integer age;
    private String email;
&#125;
</code></pre>
<h3 id="3-2-2-TableId的value属性"><a href="#3-2-2-TableId的value属性" class="headerlink" title="3.2.2 @TableId的value属性"></a>3.2.2 @TableId的value属性</h3><ul>
<li>若实体类中主键对应的属性为id，而表中表示主键的字段为uid，此时若只在属性id上添加注解@TableId，则抛出异常Unknown column ‘id’ in ‘field list’，即MyBatis-Plus仍然会将id作为表的主键操作，而表中表示主键的是字段uid</li>
<li>此时需要通过@TableId注解的value属性，指定表中的主键字段，@TableId(“uid”)或@TableId(value&#x3D;”uid”)</li>
</ul>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;
    @TableId(&quot;uid&quot;)
    private Long id;
    private String name;
    private Integer age;
    private String email;
&#125;
</code></pre>
<h3 id="3-2-3-TableId的type属性"><a href="#3-2-3-TableId的type属性" class="headerlink" title="3.2.3 @TableId的type属性"></a>3.2.3 @TableId的type属性</h3><p>type属性用来定义主键策略</p>
<h4 id="①-常见的主键策略"><a href="#①-常见的主键策略" class="headerlink" title="① 常见的主键策略"></a>① 常见的主键策略</h4><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>IdType.ASSIGN_ID（默 认）</td>
<td>基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td>
</tr>
<tr>
<td>IdType.AUTO</td>
<td>使用数据库的自增策略，注意，该类型请确保<strong>数据库设置了id自增</strong>， 否则无效</td>
</tr>
</tbody></table>
<h4 id="②-IdType源码"><a href="#②-IdType源码" class="headerlink" title="② IdType源码"></a>② IdType源码</h4><pre><code class="java">@Getter
public enum IdType &#123;
    /**
     * 数据库ID自增
     * &lt;p&gt;该类型请确保数据库设置了 ID自增 否则无效&lt;/p&gt;
     */
    AUTO(0),
    /**
     * 该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)
     */
    NONE(1),
    /**
     * 用户输入ID
     * &lt;p&gt;该类型可以通过自己注册自动填充插件进行填充&lt;/p&gt;
     */
    INPUT(2),

    /* 以下2种类型、只有当插入对象ID 为空，才自动填充。 */
    /**
     * 分配ID (主键类型为number或string）,
     * 默认实现类 &#123;@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator&#125;(雪花算法)
     *
     * @since 3.3.0
     */
    ASSIGN_ID(3),
    /**
     * 分配UUID (主键类型为 string)
     * 默认实现类 &#123;@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator&#125;(UUID.replace(&quot;-&quot;,&quot;&quot;))
     */
    ASSIGN_UUID(4);

    private final int key;

    IdType(int key) &#123;
        this.key = key;
    &#125;
&#125;
</code></pre>
<h4 id="③-配置全局主键策略"><a href="#③-配置全局主键策略" class="headerlink" title="③ 配置全局主键策略"></a>③ 配置全局主键策略</h4><pre><code class="yml">mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      table-prefix: tbl_
      # 配置MyBatis-Plus的主键策略
      id-type: auto
</code></pre>
<h3 id="3-2-4-雪花算法"><a href="#3-2-4-雪花算法" class="headerlink" title="3.2.4 雪花算法"></a>3.2.4 雪花算法</h3><h4 id="①-背景"><a href="#①-背景" class="headerlink" title="① 背景"></a>① 背景</h4><p>需要选择合适的方案去应对数据规模的增长，以应对逐渐增长的访问压力和数据量。</p>
<p>数据库的扩展方式主要包括：业务分库、主从复制，数据库分表。</p>
<h4 id="②-数据库分表"><a href="#②-数据库分表" class="headerlink" title="② 数据库分表"></a>② 数据库分表</h4><p>将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分。</p>
<p>单表数据拆分有两种方式：垂直分表和水平分表。</p>
<p><strong>垂直分表</strong></p>
<ul>
<li>垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。</li>
<li>例如，前面示意图中的 nickname 和 description 字段，假设我们是一个婚恋网站，用户在筛选其他用户的时候，主要是用 age 和 sex 两个字段进行查询，而 nickname 和 description 两个字段主要用于展示，一般不会在业务查询中用到。description 本身又比较长，因此我们可以将这两个字段独立到另外一张表中，这样在查询 age 和 sex 时，就能带来一定的性能提升。</li>
</ul>
<p><strong>水平分表</strong></p>
<ul>
<li>水平分表适合表行数特别大的表，有的公司要求单表行数超过 5000 万就必须进行分表，这个数字可以作为参考，但并不是绝对标准，关键还是要看表的访问性能。对于一些比较复杂的表，可能超过 1000万就要分表了；而对于一些简单的表，即使存储数据超过 1 亿行，也可以不分表。</li>
<li>但不管怎样，当看到表的数据量达到千万级别时，作为架构师就要警觉起来，因为这很可能是架构的性能瓶颈或者隐患。</li>
</ul>
<p>水平分表相比垂直分表，会引入更多的复杂性，例如要求全局唯一的数据id该如何处理</p>
<ul>
<li>主键自增<ul>
<li>①以最常见的用户 ID 为例，可以按照 1000000 的范围大小进行分段，1 ~ 999999 放到表中，1000000 ~ 1999999 放到表2中，以此类推。</li>
<li>②复杂点：分段大小的选取。分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适的分段大小。</li>
<li>③优点：可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，只需要增加新的表就可以了，原有的数据不需要动。</li>
<li>④缺点：分布不均匀。假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1 条，而另外一个分段实际存储的数据量有 1000 万条。</li>
</ul>
</li>
<li>取模<ul>
<li>①同样以用户 ID 为例，假如我们一开始就规划了 10 个数据库表，可以简单地用 user_id % 10 的值来表示数据所属的数据库表编号，ID 为 985 的用户放到编号为 5 的子表中，ID 为 10086 的用户放到编号为 6 的子表中。</li>
<li>②复杂点：初始表数量的确定。表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。</li>
<li>③优点：表分布比较均匀。</li>
<li>④缺点：扩充新的表很麻烦，所有数据都要重分布。</li>
</ul>
</li>
<li>雪花算法<ul>
<li>雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的主键的有序性。</li>
<li>①核心思想：<ul>
<li>长度共64bit（一个long型）。</li>
<li>首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。</li>
<li>41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。</li>
<li>10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。</li>
<li>12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。</li>
</ul>
</li>
<li>②优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。</li>
</ul>
</li>
</ul>
<h2 id="3-3-TableField"><a href="#3-3-TableField" class="headerlink" title="3.3 @TableField"></a>3.3 @TableField</h2><p>问题：如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？</p>
<h3 id="3-3-1-情况1"><a href="#3-3-1-情况1" class="headerlink" title="3.3.1 情况1"></a>3.3.1 情况1</h3><ul>
<li>若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格</li>
<li>例如实体类属性userName，表中字段user_name</li>
<li>此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格</li>
<li>相当于在MyBatis中配置</li>
</ul>
<h3 id="3-3-2-情况2"><a href="#3-3-2-情况2" class="headerlink" title="3.3.2 情况2"></a>3.3.2 情况2</h3><ul>
<li>若实体类中的属性和表中的字段不满足情况1</li>
<li>例如实体类属性name，表中字段username</li>
<li>此时需要在实体类属性上使用@TableField(“username”)设置属性所对应的字段名</li>
</ul>
<h2 id="3-4-TableLogic"><a href="#3-4-TableLogic" class="headerlink" title="3.4 @TableLogic"></a>3.4 @TableLogic</h2><h3 id="3-4-1-逻辑删除"><a href="#3-4-1-逻辑删除" class="headerlink" title="3.4.1 逻辑删除"></a>3.4.1 逻辑删除</h3><ul>
<li>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</li>
<li>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</li>
<li>使用场景：可以进行数据恢复</li>
</ul>
<h3 id="3-4-2-实现逻辑删除"><a href="#3-4-2-实现逻辑删除" class="headerlink" title="3.4.2 实现逻辑删除"></a>3.4.2 实现逻辑删除</h3><ol>
<li><p>数据库中创建逻辑删除状态列，设置默认值为0</p>
<ul>
<li>字段名：is_deleted</li>
<li>类型：int</li>
<li>默认值：0</li>
</ul>
</li>
<li><p>实体类中添加逻辑删除属性</p>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;
    @TableId(value = &quot;uid&quot;, type = IdType.ASSIGN_ID)
    private Long id;
    private String name;
    private Integer age;
//    @TableField(exist = false)
    private String email;
    @TableLogic
    private Integer isDeleted;
&#125;
</code></pre>
</li>
<li><p>测试删除</p>
<ul>
<li><p>Java代码</p>
<pre><code class="java">    @Test
    public void testDeleteById() &#123;
        //通过id删除用户信息
        //DELETE FROM user WHERE id=?
        int result = userMapper.deleteById(5);
        System.out.println(&quot;受影响行数：&quot; + result);
    &#125;
</code></pre>
</li>
<li><p>测试删除功能，真正执行的是修改</p>
<pre><code class="sql">UPDATE t_user SET is_deleted=1 WHERE id=? AND is_deleted=0
</code></pre>
</li>
<li><p>测试查询功能，被逻辑删除的数据默认不会被查询</p>
<pre><code class="sql">SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0
</code></pre>
</li>
</ul>
</li>
</ol>
<h1 id="四、条件构造器和常用接口"><a href="#四、条件构造器和常用接口" class="headerlink" title="四、条件构造器和常用接口"></a>四、条件构造器和常用接口</h1><h2 id="4-1-wapper介绍"><a href="#4-1-wapper介绍" class="headerlink" title="4.1 wapper介绍"></a>4.1 wapper介绍</h2><ul>
<li>Wrapper ： 条件构造抽象类，最顶端父类<ul>
<li>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件<ul>
<li>QueryWrapper ： 查询条件封装</li>
<li>UpdateWrapper ： Update 条件封装</li>
<li>AbstractLambdaWrapper ： 使用Lambda 语法<ul>
<li>LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper</li>
<li>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-2-QueryWrapper"><a href="#4-2-QueryWrapper" class="headerlink" title="4.2 QueryWrapper"></a>4.2 QueryWrapper</h2><h3 id="4-2-1-组装查询条件"><a href="#4-2-1-组装查询条件" class="headerlink" title="4.2.1 组装查询条件"></a>4.2.1 组装查询条件</h3><pre><code class="java">    @Test
    public void test01() &#123;
        //查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息
        //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)
        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        queryWrapper.like(&quot;username&quot;, &quot;a&quot;)
                .between(&quot;age&quot;, 20, 30)
                .isNotNull(&quot;email&quot;);
        List&lt;User&gt; list = userMapper.selectList(queryWrapper);
        list.forEach(System.out::println);
    &#125;
</code></pre>
<h3 id="4-2-2-组装排序条件"><a href="#4-2-2-组装排序条件" class="headerlink" title="4.2.2 组装排序条件"></a>4.2.2 组装排序条件</h3><pre><code class="java">@Test
public void test02()&#123;
    //按年龄降序查询用户，如果年龄相同则按id升序排列
    //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    queryWrapper
            .orderByDesc(&quot;age&quot;)
            .orderByAsc(&quot;id&quot;);
    List&lt;User&gt; users = userMapper.selectList(queryWrapper);
    users.forEach(System.out::println);
&#125;
</code></pre>
<h3 id="4-2-3-组装删除条件"><a href="#4-2-3-组装删除条件" class="headerlink" title="4.2.3 组装删除条件"></a>4.2.3 组装删除条件</h3><pre><code class="java">@Test
public void test03()&#123;
    //删除email为空的用户
    //DELETE FROM t_user WHERE (email IS NULL)
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    queryWrapper.isNull(&quot;email&quot;);
    //条件构造器也可以构建删除语句的条件
    int result = userMapper.delete(queryWrapper);
    System.out.println(&quot;受影响的行数：&quot; + result);
&#125;
</code></pre>
<h3 id="4-2-4-条件的优先级"><a href="#4-2-4-条件的优先级" class="headerlink" title="4.2.4 条件的优先级"></a>4.2.4 条件的优先级</h3><pre><code class="java">@Test
public void test04() &#123;
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    //将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改
    //UPDATE t_user SET age=?, email=? WHERE (username LIKE ? AND age &gt; ? OR email IS NULL)
    queryWrapper
            .like(&quot;username&quot;, &quot;a&quot;)
            .gt(&quot;age&quot;, 20)
            .or()
            .isNull(&quot;email&quot;);
    User user = new User();
    user.setAge(18);
    user.setEmail(&quot;user@atguigu.com&quot;);
    int result = userMapper.update(user, queryWrapper);
    System.out.println(&quot;受影响的行数：&quot; + result);
&#125;
</code></pre>
<pre><code class="java">    @Test
    public void test04() &#123;
        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改
//UPDATE t_user SET age=?, email=? WHERE (username LIKE ? AND (age &gt; ? OR email IS NULL))
//lambda表达式内的逻辑优先运算
        queryWrapper
                .like(&quot;username&quot;, &quot;a&quot;)
                .and(i -&gt; i.gt(&quot;age&quot;, 20).or().isNull(&quot;email&quot;));
        User user = new User();
        user.setAge(18);
        user.setEmail(&quot;user@atguigu.com&quot;);
        int result = userMapper.update(user, queryWrapper);
        System.out.println(&quot;受影响的行数：&quot; + result);
    &#125;
</code></pre>
<h3 id="4-2-5-组装select子句"><a href="#4-2-5-组装select子句" class="headerlink" title="4.2.5 组装select子句"></a>4.2.5 组装select子句</h3><pre><code class="java">@Test
public void test05() &#123;
    //查询用户信息的username和age字段
    //SELECT username,age FROM t_user
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    queryWrapper.select(&quot;username&quot;, &quot;age&quot;);
    //selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值 为null
    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);
    maps.forEach(System.out::println);
&#125;
</code></pre>
<h3 id="4-2-6-实现子查询"><a href="#4-2-6-实现子查询" class="headerlink" title="4.2.6 实现子查询"></a>4.2.6 实现子查询</h3><pre><code class="java">@Test
public void test06() &#123;
    //查询id小于等于3的用户信息
    //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (id IN (select id from t_user where id &lt;= 3))
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
    queryWrapper.inSql(&quot;id&quot;, &quot;select id from t_user where id &lt;= 3&quot;);
    List&lt;User&gt; list = userMapper.selectList(queryWrapper);
    list.forEach(System.out::println);
&#125;   
</code></pre>
<h2 id="4-3-UpdateWrapper"><a href="#4-3-UpdateWrapper" class="headerlink" title="4.3 UpdateWrapper"></a>4.3 UpdateWrapper</h2><pre><code class="java">@Test
public void test07() &#123;
    //将（年龄大于20或邮箱为null）并且用户名中包含有a的用户信息修改
    //组装set子句以及修改条件
    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();
    //lambda表达式内的逻辑优先运算
    updateWrapper
            .set(&quot;age&quot;, 18)
            .set(&quot;email&quot;, &quot;user@atguigu.com&quot;)
            .like(&quot;username&quot;, &quot;a&quot;)
            .and(i -&gt; i.gt(&quot;age&quot;, 20).or().isNull(&quot;email&quot;));
    //这里必须要创建User对象，否则无法应用自动填充。如果没有自动填充，可以设置为null
    //UPDATE t_user SET username=?, age=?,email=? WHERE (username LIKE ? AND (age &gt; ? OR email IS NULL))
    //User user = new User();
    //user.setName(&quot;张三&quot;);
    //int result = userMapper.update(user, updateWrapper);
    //UPDATE t_user SET age=?,email=? WHERE (username LIKE ? AND (age &gt; ? OR email IS NULL))
    int result = userMapper.update(null, updateWrapper);
    System.out.println(result);
&#125;
</code></pre>
<h2 id="4-4-condition"><a href="#4-4-condition" class="headerlink" title="4.4 condition"></a>4.4 condition</h2><p>在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果</p>
<h3 id="4-4-1-思路一"><a href="#4-4-1-思路一" class="headerlink" title="4.4.1 思路一"></a>4.4.1 思路一</h3><pre><code class="java">    @Test
    public void test08() &#123;
        //定义查询条件，有可能为null（用户未输入或未选择）
        String username = null;
        Integer ageBegin = 10;
        Integer ageEnd = 24;
        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        //StringUtils.isNotBlank()判断某字符串是否不为空且长度不为0且不由空白符(whitespace) 构成
        if (StringUtils.isNotBlank(username)) &#123;
            queryWrapper.like(&quot;username&quot;, &quot;a&quot;);
        &#125;
        if (ageBegin != null) &#123;
            queryWrapper.ge(&quot;age&quot;, ageBegin);
        &#125;
        if (ageEnd != null) &#123;
            queryWrapper.le(&quot;age&quot;, ageEnd);
        &#125;
        //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (age &gt;= ?AND age &lt;= ?)
        List&lt;User&gt; users = userMapper.selectList(queryWrapper);
        users.forEach(System.out::println);
    &#125;
</code></pre>
<h3 id="4-4-2-思路二"><a href="#4-4-2-思路二" class="headerlink" title="4.4.2 思路二"></a>4.4.2 思路二</h3><p>以使用带condition参数的重载方法构建查询条件，简化代码的编写</p>
<pre><code class="java">    @Test
    public void test08UseCondition() &#123;
        //定义查询条件，有可能为null（用户未输入或未选择）
        String username = null;
        Integer ageBegin = 10;
        Integer ageEnd = 24;
        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        //StringUtils.isNotBlank()判断某字符串是否不为空且长度不为0且不由空白符(whitespace) 构成
        queryWrapper
                .like(StringUtils.isNotBlank(username), &quot;username&quot;, &quot;a&quot;).ge(ageBegin != null, &quot;age&quot;, ageBegin)
                .le(ageEnd != null, &quot;age&quot;, ageEnd);
        //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (age &gt;= ? AND age &lt;= ?)
        List&lt;User&gt; users = userMapper.selectList(queryWrapper);
        users.forEach(System.out::println);
    &#125;
</code></pre>
<h2 id="4-5-LambdaQueryWrapper"><a href="#4-5-LambdaQueryWrapper" class="headerlink" title="4.5 LambdaQueryWrapper"></a>4.5 LambdaQueryWrapper</h2><pre><code class="java">@Test
public void test09() &#123;
    //定义查询条件，有可能为null（用户未输入）
    String username = &quot;a&quot;;
    Integer ageBegin = 10;
    Integer ageEnd = 24;
    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
    //避免使用字符串表示字段，防止运行时错误
    queryWrapper
            .like(StringUtils.isNotBlank(username), User::getName, username)
            .ge(ageBegin != null, User::getAge, ageBegin)
            .le(ageEnd != null, User::getAge, ageEnd);
    List&lt;User&gt; users = userMapper.selectList(queryWrapper);
    users.forEach(System.out::println);
&#125;
</code></pre>
<h2 id="4-6-LambdaUpdateWrapper"><a href="#4-6-LambdaUpdateWrapper" class="headerlink" title="4.6 LambdaUpdateWrapper"></a>4.6 LambdaUpdateWrapper</h2><pre><code class="java">@Test
public void test10() &#123;
    //组装set子句
    LambdaUpdateWrapper&lt;User&gt; updateWrapper = new LambdaUpdateWrapper&lt;&gt;();
    updateWrapper
            .set(User::getAge, 18)
            .set(User::getEmail, &quot;user@atguigu.com&quot;)
            .like(User::getName, &quot;a&quot;)
            .and(i -&gt; i.lt(User::getAge, 24).or().isNull(User::getEmail)); //lambda 表达式内的逻辑优先运算
    User user = new User();
    int result = userMapper.update(user, updateWrapper);
    System.out.println(&quot;受影响的行数：&quot; + result);
&#125;
</code></pre>
<h1 id="五、插件"><a href="#五、插件" class="headerlink" title="五、插件"></a>五、插件</h1><h2 id="5-1-分页插件"><a href="#5-1-分页插件" class="headerlink" title="5.1 分页插件"></a>5.1 分页插件</h2><h3 id="5-1-1-添加配置类"><a href="#5-1-1-添加配置类" class="headerlink" title="5.1.1 添加配置类"></a>5.1.1 添加配置类</h3><pre><code class="java">@Configuration
@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;) //可以将主类中的注解移到此处
public class MybatisPlusConfig &#123;
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    &#125;
&#125;
</code></pre>
<h3 id="5-1-2-自动分页"><a href="#5-1-2-自动分页" class="headerlink" title="5.1.2 自动分页"></a>5.1.2 自动分页</h3><pre><code class="java">@Test
public void testPage()&#123;
    //设置分页参数
    Page&lt;User&gt; page = new Page&lt;&gt;(1, 5);
    userMapper.selectPage(page, null);
    //获取分页数据
    List&lt;User&gt; list = page.getRecords();
    list.forEach(System.out::println);
    System.out.println(&quot;当前页：&quot;+page.getCurrent());
    System.out.println(&quot;每页显示的条数：&quot;+page.getSize());
    System.out.println(&quot;总记录数：&quot;+page.getTotal());
    System.out.println(&quot;总页数：&quot;+page.getPages());
    System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious());
    System.out.println(&quot;是否有下一页：&quot;+page.hasNext());
&#125;
</code></pre>
<h3 id="5-1-3-xml自定义分页"><a href="#5-1-3-xml自定义分页" class="headerlink" title="5.1.3 xml自定义分页"></a>5.1.3 xml自定义分页</h3><h4 id="①-定义Mapper接口方法"><a href="#①-定义Mapper接口方法" class="headerlink" title="① 定义Mapper接口方法"></a>① 定义Mapper接口方法</h4><pre><code class="java">@Mapper
@Repository
public interface CustomerMapper extends BaseMapper&lt;Customer&gt; &#123;
    IPage&lt;Customer&gt; selectPage(Page&lt;Customer&gt; pageParam,@Param(&quot;vo&quot;) CustomerVo customerVo);
&#125;
</code></pre>
<h4 id="②-定义Mapper映射文件"><a href="#②-定义Mapper映射文件" class="headerlink" title="② 定义Mapper映射文件"></a>② 定义Mapper映射文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.bamboo.warehouseerp.mapper.CustomerMapper&quot;&gt;

    &lt;resultMap id=&quot;CustomerMap&quot; type=&quot;com.bamboo.warehouseerp.pojo.Customer&quot; autoMapping=&quot;true&quot;/&gt;

    &lt;sql id=&quot;columns&quot;&gt;
        id,name,receipt_number,commodity_information,bill_date,operator,total_amount,state,create_time,update_time,is_deleted
    &lt;/sql&gt;
    &lt;select id=&quot;selectPage&quot; resultMap=&quot;CustomerMap&quot;&gt;
        select
        &lt;include refid=&quot;columns&quot;/&gt;
        from customer
        &lt;where&gt;
            &lt;if test=&quot;vo.receiptNumber != null and vo.receiptNumber != &#39;&#39;&quot;&gt;
                and receipt_number like CONCAT(&#39;%&#39;,#&#123;vo.receiptNumber&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;vo.commodityInformation != null and vo.commodityInformation != &#39;&#39;&quot;&gt;
                and commodity_information like CONCAT(&#39;%&#39;,#&#123;vo.commodityInformation&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;vo.oldDate != null and vo.oldDate != &#39;&#39;&quot;&gt;
                and bill_date &amp;gt;= #&#123;vo.oldDate&#125;
            &lt;/if&gt;
            &lt;if test=&quot;vo.newDate != null and vo.newDate != &#39;&#39;&quot;&gt;
                and bill_date &amp;lt;= #&#123;vo.newDate&#125;
            &lt;/if&gt;
            and is_deleted = 0
        &lt;/where&gt;
        order by id desc
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="③-Service层嵌套mapper"><a href="#③-Service层嵌套mapper" class="headerlink" title="③ Service层嵌套mapper"></a>③ Service层嵌套mapper</h4><pre><code class="java">@Service
public class CustomerServiceImpl extends ServiceImpl&lt;CustomerMapper, Customer&gt; implements CustomerService &#123;
    @Autowired
    private CustomerMapper customerMapper;
    @Override
    public IPage&lt;Customer&gt; selectPage(Page&lt;Customer&gt; pageParam, CustomerVo customerVo) &#123;
        return customerMapper.selectPage(pageParam, customerVo);
    &#125;
&#125;
</code></pre>
<h4 id="④-Controller层调用"><a href="#④-Controller层调用" class="headerlink" title="④ Controller层调用"></a>④ Controller层调用</h4><pre><code class="java">@GetMapping(&quot;&#123;page&#125;/&#123;limit&#125;&quot;)
    public Result getPageList(
            @PathVariable(&quot;page&quot;) Long page,
            @PathVariable(&quot;limit&quot;) Long limit,
            CustomerVo customerVo
    ) &#123;
        Page&lt;Customer&gt; pageParam = new Page&lt;&gt;(page, limit);
        IPage&lt;Customer&gt; pageModel = customerService.selectPage(pageParam, customerVo);
        return Result.ok(pageModel);
    &#125;
</code></pre>
<h2 id="5-2-乐观锁"><a href="#5-2-乐观锁" class="headerlink" title="5.2 乐观锁"></a>5.2 乐观锁</h2><h3 id="5-2-1-乐观锁与悲观锁"><a href="#5-2-1-乐观锁与悲观锁" class="headerlink" title="5.2.1 乐观锁与悲观锁"></a>5.2.1 乐观锁与悲观锁</h3><ul>
<li>乐观锁<ul>
<li>修改数据前会检查数据是否被修改过。如果被修改过了，则重新取出的被修改后的数据</li>
</ul>
</li>
<li>悲观锁<ul>
<li>在一个修改操作彻底结束后才能进行下一次操作，即等待</li>
</ul>
</li>
</ul>
<h3 id="5-2-2-模拟修改冲突"><a href="#5-2-2-模拟修改冲突" class="headerlink" title="5.2.2 模拟修改冲突"></a>5.2.2 模拟修改冲突</h3><p>数据表</p>
<pre><code class="sql">CREATE TABLE t_product
(
id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;,
NAME VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;商品名称&#39;,
price INT(11) DEFAULT 0 COMMENT &#39;价格&#39;,
VERSION INT(11) DEFAULT 0 COMMENT &#39;乐观锁版本号&#39;,
PRIMARY KEY (id)
);
</code></pre>
<p>添加数据</p>
<pre><code class="sql">INSERT INTO t_product (id, NAME, price) VALUES (1, &#39;外星人笔记本&#39;, 100);
</code></pre>
<p>添加实体</p>
<pre><code class="java">@Data
public class Product &#123;
    private Long id;
    private String name;
    private Integer price;
    private Integer version;
&#125;
</code></pre>
<p>添加mapper</p>
<pre><code class="java">public interface ProductMapper extends BaseMapper&lt;Product&gt; &#123;
&#125;
</code></pre>
<p>测试</p>
<pre><code class="java">@SpringBootTest
public class ProductTest &#123;

    @Autowired
    private ProductMapper productMapper;

    @Test
    public void testConcurrentUpdate() &#123;
        //1、小李
        Product p1 = productMapper.selectById(1L);
        System.out.println(&quot;小李取出的价格：&quot; + p1.getPrice());
        //2、小王
        Product p2 = productMapper.selectById(1L);
        System.out.println(&quot;小王取出的价格：&quot; + p2.getPrice());
        //3、小李将价格加了50元，存入了数据库
        p1.setPrice(p1.getPrice() + 50);
        int result1 = productMapper.updateById(p1);
        System.out.println(&quot;小李修改结果：&quot; + result1);
        //4、小王将商品减了30元，存入了数据库
        p2.setPrice(p2.getPrice() - 30);
        int result2 = productMapper.updateById(p2);
        System.out.println(&quot;小王修改结果：&quot; + result2);
        //最后的结果
        Product p3 = productMapper.selectById(1L);
        //价格覆盖，最后的结果：70
        System.out.println(&quot;最后的结果：&quot; + p3.getPrice());
    &#125;
&#125;
</code></pre>
<h3 id="5-2-3-乐观锁实现流程"><a href="#5-2-3-乐观锁实现流程" class="headerlink" title="5.2.3 乐观锁实现流程"></a>5.2.3 乐观锁实现流程</h3><ul>
<li><p>数据库中添加version字段，实体类标注解<code>@Version</code></p>
</li>
<li><p>取出记录时，获取当前version</p>
<pre><code class="sql">SELECT id,name,price,version FROM product WHERE id=1
</code></pre>
</li>
<li><p>更新时，version + 1，如果where语句中的version版本不对，则更新失败</p>
<pre><code class="sql">UPDATE product SET price=price+50, version=version + 1 WHERE id=1 AND version=1
</code></pre>
</li>
</ul>
<h3 id="5-2-4-Mybatis-Plus实现乐观锁"><a href="#5-2-4-Mybatis-Plus实现乐观锁" class="headerlink" title="5.2.4 Mybatis-Plus实现乐观锁"></a>5.2.4 Mybatis-Plus实现乐观锁</h3><h4 id="①-实体类标注-Version"><a href="#①-实体类标注-Version" class="headerlink" title="① 实体类标注@Version"></a>① 实体类标注@Version</h4><p>修改实体类</p>
<pre><code class="java">@Data
@TableName(&quot;t_product&quot;)
public class Product &#123;
    private Long id;
    private String name;
    private Integer price;
    @Version
    private Integer version;
&#125;
</code></pre>
<h4 id="②-添加乐观锁插件配置"><a href="#②-添加乐观锁插件配置" class="headerlink" title="② 添加乐观锁插件配置"></a>② 添加乐观锁插件配置</h4><pre><code class="java">@Configuration
public class MybatisPlusConfig &#123;
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        //添加分页插件
        interceptor.addInnerInterceptor(new
                PaginationInnerInterceptor(DbType.MYSQL));
        //添加乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return interceptor;
    &#125;
&#125;
</code></pre>
<h4 id="③-测试"><a href="#③-测试" class="headerlink" title="③ 测试"></a>③ 测试</h4><pre><code class="java">@Test
public void testConcurrentVersionUpdate() &#123;
    //小李取数据
    Product p1 = productMapper.selectById(1L);
    //小王取数据
    Product p2 = productMapper.selectById(1L);
    //小李修改 + 50
    p1.setPrice(p1.getPrice() + 50);
    int result1 = productMapper.updateById(p1);
    System.out.println(&quot;小李修改的结果：&quot; + result1);
    //小王修改 - 30
    p2.setPrice(p2.getPrice() - 30);
    int result2 = productMapper.updateById(p2);
    System.out.println(&quot;小王修改的结果：&quot; + result2);
    if (result2 == 0) &#123;
    //失败重试，重新获取version并更新
        p2 = productMapper.selectById(1L);
        p2.setPrice(p2.getPrice() - 30);
        result2 = productMapper.updateById(p2);
    &#125;
    System.out.println(&quot;小王修改重试的结果：&quot; + result2);
    //老板看价格
    Product p3 = productMapper.selectById(1L);
    System.out.println(&quot;老板看价格：&quot; + p3.getPrice());
&#125;
</code></pre>
<h1 id="六、通用枚举"><a href="#六、通用枚举" class="headerlink" title="六、通用枚举"></a>六、通用枚举</h1><p>表中的有些字段值是固定的，例如性别（男或女），可以使用MyBatis-Plus的通用枚举来实现</p>
<h2 id="6-1-旧版配置"><a href="#6-1-旧版配置" class="headerlink" title="6.1 旧版配置"></a>6.1 旧版配置</h2><ol>
<li><p>数据库表添加字段sex</p>
<ul>
<li>字段：sex</li>
<li>类型：int</li>
</ul>
</li>
<li><p>创建通用枚举类型</p>
<pre><code class="java">@Getter
public enum SexEnum &#123;
    MALE(1, &quot;男&quot;),
    FEMALE(2, &quot;女&quot;);
    @EnumValue
    private Integer sex;
    private String sexName;

    SexEnum(Integer sex, String sexName) &#123;
        this.sex = sex;
        this.sexName = sexName;
    &#125;
&#125;
</code></pre>
</li>
<li><p>配置扫描通用枚举【3.5.2版本开始弃用】</p>
<pre><code class="java">mybatis-plus:
  type-enums-package: com.bamboo.boot.enums
</code></pre>
</li>
</ol>
<h2 id="6-2-新版配置"><a href="#6-2-新版配置" class="headerlink" title="6.2 新版配置"></a>6.2 新版配置</h2><p>3.5.2版本开始实现一步就可枚举</p>
<h3 id="6-2-1-方式一"><a href="#6-2-1-方式一" class="headerlink" title="6.2.1 方式一"></a>6.2.1 方式一</h3><p><strong>使用 @EnumValue 注解枚举属性</strong></p>
<pre><code class="java">@Getter
public enum SexEnum &#123;
    MALE(1, &quot;男&quot;),
    FEMALE(2, &quot;女&quot;);
    @EnumValue
    private Integer sex;
    private String sexName;

    SexEnum(Integer sex, String sexName) &#123;
        this.sex = sex;
        this.sexName = sexName;
    &#125;
&#125;
</code></pre>
<h3 id="6-2-2-方式二"><a href="#6-2-2-方式二" class="headerlink" title="6.2.2 方式二"></a>6.2.2 方式二</h3><p>枚举属性，实现 IEnum 接口</p>
<pre><code class="java">public enum AgeEnum implements IEnum&lt;Integer&gt; &#123;
    ONE(1, &quot;一岁&quot;),
    TWO(2, &quot;二岁&quot;),
    THREE(3, &quot;三岁&quot;);

    private int value;
    private String desc;

    @Override
    public Integer getValue() &#123;
        return this.value;
    &#125;
&#125;
</code></pre>
<p>实体属性使用枚举类型</p>
<pre><code class="java">public class User &#123;
    /**
     * 名字
     * 数据库字段: name varchar(20)
     */
    private String name;

    /**
     * 年龄，IEnum接口的枚举处理
     * 数据库字段：age INT(3)
     */
    private AgeEnum age;


    /**
     * 年级，原生枚举（带&#123;@link com.baomidou.mybatisplus.annotation.EnumValue&#125;):
     * 数据库字段：grade INT(2)
     */
    private GradeEnum grade;
&#125;
</code></pre>
<h2 id="6-3-测试"><a href="#6-3-测试" class="headerlink" title="6.3 测试"></a>6.3 测试</h2><pre><code class="java">@Test
public void testSexEnum()&#123;
    User user = new User();
    user.setName(&quot;Enum&quot;);
    user.setAge(20);
    //设置性别信息为枚举项，会将@EnumValue注解所标识的属性值存储到数据库
    user.setSex(SexEnum.MALE);
    //INSERT INTO t_user ( username, age, sex ) VALUES ( ?, ?, ? )
    //Parameters: Enum(String), 20(Integer), 1(Integer)
    userMapper.insert(user);
&#125;
</code></pre>
<h1 id="七、代码生成器"><a href="#七、代码生成器" class="headerlink" title="七、代码生成器"></a>七、代码生成器</h1><h2 id="7-1-引入依赖"><a href="#7-1-引入依赖" class="headerlink" title="7.1 引入依赖"></a>7.1 引入依赖</h2><pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.31&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h2 id="7-2-快速生成"><a href="#7-2-快速生成" class="headerlink" title="7.2 快速生成"></a>7.2 快速生成</h2><pre><code class="java">public class FastAutoGeneratorTest &#123;
    public static void main(String[] args) &#123;
        FastAutoGenerator.create(&quot;jdbc:mysql://127.0.0.1:3306/mybatis_plus?characterEncoding=utf-8&amp;&amp;userSSL=false&quot;, &quot; root&quot;, &quot;root&quot;)
                        .globalConfig(builder -&gt; &#123;
                            builder.author(&quot;bamboo&quot;) // 设置作者
                                    //.enableSwagger() // 开启 swagger 模式
                                    .fileOverride() // 覆盖已生成文件
                                    .outputDir(&quot;D://mybatis_plus&quot;); // 指定输出目录
                        &#125;)
                        .packageConfig(builder -&gt; &#123;
                            builder.parent(&quot;com.bamboo&quot;) // 设置父包名
                                    .moduleName(&quot;mybatisplus&quot;) // 设置父包模块名
                                    .pathInfo(Collections.singletonMap(OutputFile.mapperXml, &quot;D://mybatis_plus&quot;)); // 设置mapperXml生成路径
                        &#125;)
                        .strategyConfig(builder -&gt; &#123;
                            builder.addInclude(&quot;tbl_user&quot;) // 设置需要生成的表名
                                    .addTablePrefix(&quot;tbl_&quot;, &quot;c_&quot;); // 设置过滤表前缀：通俗易懂来说就是去掉生成pojo的前缀名，和上述addInclude对应即可
                        &#125;)
                        .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板
                        .execute();
    &#125;

&#125;
</code></pre>
<h1 id="八、多数据源"><a href="#八、多数据源" class="headerlink" title="八、多数据源"></a>八、多数据源</h1><p>适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等</p>
<p>模拟一个纯粹多库的一个场景，其他场景类似：</p>
<ul>
<li>我们创建两个库，分别为：mybatis_plus（以前的库不动）与mybatis_plus_1（新建）</li>
<li>将mybatis_plus库的product表移动到mybatis_plus_1库</li>
<li>每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功</li>
</ul>
<h2 id="8-1-创建数据库及表"><a href="#8-1-创建数据库及表" class="headerlink" title="8.1 创建数据库及表"></a>8.1 创建数据库及表</h2><p>创建数据库mybatis_plus_1和表product</p>
<ul>
<li>复制数据库mybatis_plus的表product到第二个数据库中</li>
<li>将mybatis_plus数据库中的product表删除</li>
<li>两个数据库一人一个不同的表</li>
</ul>
<h2 id="8-2-引入依赖"><a href="#8-2-引入依赖" class="headerlink" title="8.2 引入依赖"></a>8.2 引入依赖</h2><pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.5.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h2 id="8-3-配置多数据源"><a href="#8-3-配置多数据源" class="headerlink" title="8.3 配置多数据源"></a>8.3 配置多数据源</h2><blockquote>
<p>说明：注释掉之前的数据库连接，添加新配置</p>
</blockquote>
<pre><code class="yml">spring:
  # 配置数据源信息
  datasource:
    dynamic:
      # 设置默认的数据源或者数据源组,默认值即为master
      primary: master
      # 严格匹配数据源,默认false,true未匹配到指定数据源时抛异常,false使用默认数据源
      strict: false
      datasource:
        master:
          url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf8&amp;useSSL=false
          driver-class-name: com.mysql.cj.jdbc.Driver
          username: root
          password: root
        slave_1:
          url: jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf8&amp;useSSL=false
          driver-class-name: com.mysql.cj.jdbc.Driver
          username: root
          password: root
</code></pre>
<h2 id="8-4-创建用户和商品的service"><a href="#8-4-创建用户和商品的service" class="headerlink" title="8.4 创建用户和商品的service"></a>8.4 创建用户和商品的service</h2><p>用户service</p>
<pre><code class="java">@DS(&quot;master&quot;) //指定所操作的数据源
@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;
&#125;
</code></pre>
<p>商品service</p>
<pre><code class="java">@DS(&quot;slave_1&quot;)
@Service
public class ProductServiceImpl extends ServiceImpl&lt;ProductMapper, Product&gt; implements ProductService &#123;
&#125;
</code></pre>
<h2 id="8-5-测试"><a href="#8-5-测试" class="headerlink" title="8.5 测试"></a>8.5 测试</h2><pre><code class="java">@SpringBootTest
class MainApplicationTests &#123;

    @Autowired
    private ProductService productService;

    @Autowired
    private UserService userService;

    @Test
    void contextLoads() &#123;
        System.out.println(userService.getById(1L));
        System.out.println(productService.getById(1L));
    &#125;

&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 竹客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Bamboo
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        




        
    </body>
</html>
