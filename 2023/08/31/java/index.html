<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java | 竹间小客</title><meta name="author" content="Bamboo,YT000000X@163.com"><meta name="copyright" content="Bamboo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、概述1.1 内存1Ghz &#x3D; 1024Mhz &#x3D; 1024^2Khz &#x3D; 1024^3hz   1.1.2 DOS命令dir md rd cd cd.. cd\ del cls exit*echo javase&gt;1.doc  Java之父：詹姆斯高斯林 1.2 特点面向对象（三大特性：封装、继承、多态），健壮性，跨平台性（不同操作系统的JVM）  JDK：J">
<meta property="og:type" content="article">
<meta property="og:title" content="java">
<meta property="og:url" content="http://blog.dragonbamboo.com/2023/08/31/java/index.html">
<meta property="og:site_name" content="竹间小客">
<meta property="og:description" content="一、概述1.1 内存1Ghz &#x3D; 1024Mhz &#x3D; 1024^2Khz &#x3D; 1024^3hz   1.1.2 DOS命令dir md rd cd cd.. cd\ del cls exit*echo javase&gt;1.doc  Java之父：詹姆斯高斯林 1.2 特点面向对象（三大特性：封装、继承、多态），健壮性，跨平台性（不同操作系统的JVM）  JDK：J">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.dragonbamboo.com/img/ava.jpg">
<meta property="article:published_time" content="2023-08-31T05:37:54.000Z">
<meta property="article:modified_time" content="2023-08-31T05:39:08.521Z">
<meta property="article:author" content="Bamboo">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.dragonbamboo.com/img/ava.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.dragonbamboo.com/2023/08/31/java/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-31 13:39:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/ava.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标题</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/description.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="竹间小客"><span class="site-name">竹间小客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标题</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-31T05:37:54.000Z" title="发表于 2023-08-31 13:37:54">2023-08-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-31T05:39:08.521Z" title="更新于 2023-08-31 13:39:08">2023-08-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-内存"><a href="#1-1-内存" class="headerlink" title="1.1 内存"></a>1.1 内存</h2><p>1Ghz &#x3D; 1024Mhz &#x3D; 1024^2Khz &#x3D; 1024^3hz</p>
<!--8bit = 1byte-->

<h3 id="1-1-2-DOS命令"><a href="#1-1-2-DOS命令" class="headerlink" title="1.1.2 DOS命令"></a>1.1.2 DOS命令</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> <span class="built_in">md</span> <span class="built_in">rd</span> <span class="built_in">cd</span> <span class="built_in">cd</span>.. <span class="built_in">cd</span>\ <span class="built_in">del</span> <span class="built_in">cls</span> <span class="keyword">exit</span></span><br><span class="line">*<span class="built_in">echo</span> javase&gt;<span class="number">1</span>.doc</span><br></pre></td></tr></table></figure>

<p>Java之父：詹姆斯高斯林</p>
<h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><p>面向对象（三大特性：封装、继承、多态），健壮性，跨平台性（不同操作系统的JVM）</p>
<ul>
<li><p>JDK：Java开发工具包，包含Java开发工具和JRE</p>
</li>
<li><p>JRE：java运行环境，包含JVM和JavaSE标准类库</p>
</li>
</ul>
<h2 id="1-3-编译"><a href="#1-3-编译" class="headerlink" title="1.3 编译"></a>1.3 编译</h2><p>javac编译 java运行</p>
<h1 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h1><p>Windows不区分大小写，所以cmd运行java命令时对文件名大小写不严格区分</p>
<h2 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">单行：<span class="comment">//方便自己，方便别人</span></span><br><span class="line">多行：<span class="comment">/* */</span></span><br><span class="line">文档注释：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 作者名</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> v1.0版本</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">文档注释调出方法javadoc -d 文件夹名 -author -version 类.java</span><br><span class="line"><span class="comment">//多行注释不可以嵌套使用</span></span><br></pre></td></tr></table></figure>



<h2 id="2-2-规范"><a href="#2-2-规范" class="headerlink" title="2.2 规范"></a>2.2 规范</h2><p>一个源文件最多只能有一个可以声明为public类，且public类需与文件名相同</p>
<p><strong>标识符identifier</strong></p>
<ul>
<li>英文，数字，下划线，美元符号组成</li>
<li>&#x2F;&#x2F;java使用Unicode字符集，可用汉字不建议使用</li>
</ul>
<p><strong>变量</strong></p>
<ul>
<li>先声明后使用</li>
<li>&#x2F;&#x2F;作用域：{代码块}，同一定义域不允许重名变量声明</li>
</ul>
<h2 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h2><h3 id="2-3-1-基本数据类型"><a href="#2-3-1-基本数据类型" class="headerlink" title="2.3.1 基本数据类型"></a>2.3.1 基本数据类型</h3><ul>
<li>byte(1) </li>
<li>short(2) </li>
<li>int(4) </li>
<li>long(8) </li>
<li>float(4) </li>
<li>double(8) </li>
<li>char(2) </li>
<li>boolean(1)</li>
</ul>
<h3 id="2-3-2-引用数据类型"><a href="#2-3-2-引用数据类型" class="headerlink" title="2.3.2 引用数据类型"></a>2.3.2 引用数据类型</h3><p>class interface []数组</p>
<h3 id="2-3-3-数据类型规则"><a href="#2-3-3-数据类型规则" class="headerlink" title="2.3.3 数据类型规则"></a>2.3.3 数据类型规则</h3><ul>
<li><p>byte：8bit &#x3D; 2^8 &#x3D;-128~127</p>
</li>
<li><p>整型常量默认int，long类型需要末尾增加’L’</p>
</li>
<li><p>浮点型常量默认double，float类型需要末尾增加’F’</p>
</li>
<li><p>&#x2F;&#x2F;float(4字节)表示数值要大于long(8字节)类型，字节存储内容不同</p>
</li>
<li><p>‘\n’换行符 ‘\t’制表符 ‘\u0043’Unicode编码 &quot;等于”</p>
</li>
<li><p>char类型必须存放一个字符</p>
</li>
</ul>
<h3 id="2-3-4-UTF-8编码"><a href="#2-3-4-UTF-8编码" class="headerlink" title="2.3.4 UTF-8编码"></a>2.3.4 UTF-8编码</h3><p>文件和控制台编码不同会导致乱码</p>
<h3 id="2-3-5-类型转换"><a href="#2-3-5-类型转换" class="headerlink" title="2.3.5 类型转换"></a>2.3.5 类型转换</h3><h4 id="①-自动类型提升"><a href="#①-自动类型提升" class="headerlink" title="① 自动类型提升"></a>① 自动类型提升</h4><p>byte,char,short-&gt;int-&gt;long-&gt;float-&gt;double<br>&#x2F;&#x2F;容量大小指数的范围大小，当前三种变量做运算时结果为int型</p>
<h4 id="②-强制类型转换"><a href="#②-强制类型转换" class="headerlink" title="② 强制类型转换"></a>② 强制类型转换</h4><p>(低类型)高类型</p>
<h3 id="2-3-6-进制转换"><a href="#2-3-6-进制转换" class="headerlink" title="2.3.6 进制转换"></a>2.3.6 进制转换</h3><ul>
<li><p>0B二进制 十进制 0八进制 0X十六进制</p>
</li>
<li><p>二进制内最高位0是正数1是负数</p>
</li>
<li><p>反码：原码取反</p>
</li>
<li><p>补码：反码+1</p>
</li>
<li><p>正数：原码，反码，补码相同</p>
</li>
<li><p>负数：原码符号位取1，反码为对原码除符号位外取反，补码+1</p>
</li>
<li><p>integer内toXXX有转换进制的方法</p>
</li>
</ul>
<h3 id="2-3-7运算符"><a href="#2-3-7运算符" class="headerlink" title="2.3.7运算符"></a>2.3.7运算符</h3><p><strong>算术</strong></p>
<ul>
<li>%取模结果符号与被取模数符号相同</li>
<li>%10取个位 &#x2F;10%10取十位 &#x2F;10&#x2F;10%10取百位</li>
</ul>
<p> <strong>位运算符</strong></p>
<ul>
<li>&lt;&lt;左移：每移动1位相当于*2 </li>
<li>右移：每移动1位相当于&#x2F;2，最高位原来是啥就补啥</li>
<li>无符号右移：最高位补0</li>
</ul>
<p>使用位运算符进行交换数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num1 = num1 ^num2;</span><br><span class="line">num2 = num1 ^num2;</span><br><span class="line">num1 = num1 ^num2;</span><br></pre></td></tr></table></figure>



<p><strong>三元运算符</strong><br>条件表达式?值1：值2;&#x2F;&#x2F;统一值类型，三元可嵌套<br>运算符优先级：()小括号运算最优，编写时常用即可</p>
<h2 id="2-4-程序流程控制"><a href="#2-4-程序流程控制" class="headerlink" title="2.4 程序流程控制"></a>2.4 程序流程控制</h2><p>顺序，分支，循环<br><strong>分支结构</strong><br>if(boolean)-else<br>switch(byte,short,char,int,enum5.0,String7.0)-case-default-break<br><strong>循环结构</strong><br>for(初始化条件;循环条件;迭代条件){循环体}<br>while() || do…while()<br>嵌套循环：外层控制行，内层控制列<br><strong>跳出结构</strong><br>break continue &#x2F;&#x2F;lable：标签,跳出语句后不可有语句</p>
<h1 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h1><ul>
<li><p>相同类型数据顺序排列并命名</p>
</li>
<li><p>数组名 元素 下标|索引 长度</p>
</li>
<li><p>特点：有序，引用类型，开辟的空间连续，长度确定后不可更改</p>
</li>
<li><p>分类：一维数组，二维数组…</p>
</li>
<li><p>声明：type[] arr &#x3D; new type[]{…}静态 || new type[num]动态;</p>
</li>
<li><p>长度：arr.length</p>
</li>
<li><p>遍历：fori foreach lambda</p>
</li>
<li><p>默认初始化值</p>
</li>
<li><p>整型：0 浮点型：0.0 字符：\u0000(ASCII编码0) boolean：false</p>
</li>
<li><p>引用类型：null</p>
</li>
</ul>
<p><strong>常见异常</strong></p>
<ul>
<li>NullPointerException</li>
<li>ArrayIndexOutOfBoundsException</li>
</ul>
<p>二维数组时第一维放置地址值，第二维放置类型默认值，但声明new type[num][]时，一维数组内值为null,二维数组未初始化直接使用会进行报错提示</p>
<h1 id="四、常见算法"><a href="#四、常见算法" class="headerlink" title="四、常见算法"></a>四、常见算法</h1><p><strong>杨辉三角</strong><br>(a+b)^n<br>&#x2F;&#x2F;n为杨辉三角中的行数，当n&#x3D;2时，杨辉三角二行系数为121，即a^2+2ab+b^2<br>[i][0]以及[i][i]的所有元素赋值1<br>第三行开始j&#x3D;1;j&lt;length-1使用算法<code>ij=[i-1][j-1]+[i-1][j]</code></p>
<p><strong>二分查找</strong><br>前提：有序<br>有一个头索引0和尾索引length-1<br>设置middle&#x3D;(head+end)&#x2F;2<br>if-elseif-else判断相等小于大于条件</p>
<p><strong>排序算法</strong><br>衡量算法：时间复杂度，空间复杂度，稳定性<br>十大内部排序算法：选择排序(直接选择排序，堆排序)，交换排序(<em>冒泡排序，</em>快速排序)，插入排序(直接插入排序，折半插入排序，希尔排序)，归并排序，桶式排序，基数排序</p>
<p><strong>算法特性</strong><br>输入输出，有穷性，确定性，可行性</p>
<p><strong>冒泡排序</strong><br>外层循环0<del>&lt;length-1循环n-1次<br>内层循环0</del>&lt;length-1-i比较长度次数<br>判断条件：i和i+1比较<br>快速排序，归并排序&#x2F;&#x2F;非常牛逼的东西</p>
<h1 id="五、内存结构"><a href="#五、内存结构" class="headerlink" title="五、内存结构"></a>五、内存结构</h1><ul>
<li>栈stack(局部变量)</li>
<li>堆heap<code>[地址值0x0000](new的对象、数组)</code></li>
<li>方法区methodArea(类的加载信息，常量池tring，静态域static)</li>
</ul>
<p>new Heap堆：新生区，养老区，永久存储区(不在堆内，其实是方法区)</p>
<p>虽然JVM规范将方法区描述为堆的一个逻辑部分，但它还有一个别名叫做Non-Heap(非堆)，目的就是和堆分开。</p>
<ul>
<li><p>JDK1.6中字符串常量池被划分在方法区中(具体实现：永久代)</p>
</li>
<li><p>JDK1.7中字符串常量池被划分到堆中(具体实现：永久代)</p>
</li>
<li><p>JDK1.8中字符串常量池被重新划分在方法区中 (具体实现：元空间)，元数据区取代了永久代，元空间的本质和永久代类似，都是对JVM规范中方法区的实现</p>
</li>
</ul>
<p><strong>三种JVM</strong></p>
<ul>
<li><p>SUN公司的HotSpot</p>
</li>
<li><p>BEA公司的JRockit</p>
</li>
<li><p>IBM公司的J9 VM</p>
</li>
</ul>
<h1 id="六、面向对象OOP"><a href="#六、面向对象OOP" class="headerlink" title="六、面向对象OOP"></a>六、面向对象OOP</h1><p><strong>Java类及类成员</strong>：属性、方法、构造器、代码块、内部类<br><strong>三大特征</strong></p>
<ul>
<li>封装性</li>
<li>继承性</li>
<li>多态性[(抽象性)]</li>
<li>其它关键字：this,super,static,final,abstract,interface,package,import</li>
</ul>
<p>类Class抽象的概念上的定义<br>对象是实际存在的，也叫做实例instance</p>
<ul>
<li><p>属性&#x3D;成员变量&#x3D;filed&#x3D;域、字段</p>
</li>
<li><p>行为&#x3D;成员方法&#x3D;method&#x3D;函数</p>
</li>
<li><p>创建类的对象&#x3D;类的实例化&#x3D;实例化类</p>
</li>
<li><p>return：使用在方法中，可直接结束方法运行</p>
</li>
</ul>
<p>匿名对象：直接使用new Class().method()来使用，只能调用一次</p>
<p>自定义工具类：Util结尾，私有化构造器，静态方法</p>
<h2 id="6-1-细谈方法"><a href="#6-1-细谈方法" class="headerlink" title="6.1 细谈方法"></a>6.1 细谈方法</h2><p><strong>方法重载overload</strong></p>
<ul>
<li>同名方法，参数个数或参数类型或参数类型顺序不同</li>
</ul>
<p><strong>方法重写override</strong></p>
<ul>
<li>子类同名方法，参数相同</li>
<li>重写后权限修饰符不小于父类权限，private不能重写</li>
<li>重写后返回值只能是父类返回类型或父类返回类型的子类型</li>
<li>可变形参：Type … variable，形式为数组，0~n个形参可填写，只能声明在最后一个</li>
<li>参数传值：基本数据类型传数据值，引用数据类型传地址值</li>
</ul>
<p>调用方法时可以不接收返回值</p>
<h2 id="6-2-递归recursion"><a href="#6-2-递归recursion" class="headerlink" title="6.2 递归recursion"></a>6.2 递归recursion</h2><p>递归加法，阶乘，裴波那契数列(Fibonacci)，汉诺塔，快速排序</p>
<h2 id="6-3-封装和隐藏"><a href="#6-3-封装和隐藏" class="headerlink" title="6.3 封装和隐藏"></a>6.3 封装和隐藏</h2><ul>
<li><p>高内聚，低耦合</p>
</li>
<li><p>private私有全局变量</p>
</li>
<li><p>设置公共的getter和setter方法</p>
</li>
<li><p>封装性的体现：单例模式</p>
</li>
</ul>
<h2 id="6-4-继承extends"><a href="#6-4-继承extends" class="headerlink" title="6.4 继承extends"></a>6.4 继承extends</h2><ul>
<li>减少代码冗余，提高代码复用性，便于扩展，多态前提</li>
<li>子类：派生类</li>
<li>父类：超类，基类</li>
<li>子类继承后会获取父类所有属性和方法</li>
<li>因为封装性的影响，继承的private属性不可以直接调用父类private属性，通过gettersetter方法的继承调用</li>
<li>单继承</li>
<li>所有的类继承于java.lang.Object类</li>
</ul>
<h2 id="6-5多态"><a href="#6-5多态" class="headerlink" title="6.5多态"></a>6.5多态</h2><ul>
<li>一个事物的多种形态</li>
<li>方法：编译看左，运行看右</li>
<li>变量：没有多态</li>
<li>使用instanceof判断是否是类实例进行向下转型</li>
</ul>
<h2 id="6-6-访问权限修饰符"><a href="#6-6-访问权限修饰符" class="headerlink" title="6.6 访问权限修饰符"></a>6.6 访问权限修饰符</h2><p><strong>类内部：private</strong></p>
<ul>
<li>同一包下：private 缺省(友好类)</li>
<li>不同包的子类：private 缺省(友好类) protected</li>
<li>同一个工程：private 缺省(友好类) protected public</li>
<li>&#x2F;&#x2F;修饰类的内部结构：属性，方法，构造器，内部类</li>
<li>&#x2F;&#x2F;类Class权限：public 缺省</li>
</ul>
<p><strong>构造器constructor</strong></p>
<ul>
<li>默认含有无参构造器，创建有参构造器后默认无参构造器消失</li>
<li>多个构造器共存组成重载</li>
</ul>
<h2 id="6-7-JavaBean"><a href="#6-7-JavaBean" class="headerlink" title="6.7 JavaBean"></a>6.7 JavaBean</h2><ul>
<li><p>公共类</p>
</li>
<li><p>有无参公共构造器</p>
</li>
<li><p>有属性且对应gettersetter方法</p>
</li>
</ul>
<h2 id="6-8-包装类"><a href="#6-8-包装类" class="headerlink" title="6.8 包装类"></a>6.8 包装类</h2><p><strong>八种基本类型的引用类型</strong></p>
<ul>
<li>Type type &#x3D; new Type(type variable)</li>
<li>自动装箱：包装类 var &#x3D; 基本类型数据</li>
<li>自动拆箱：基本类型 var &#x3D; 包装类对象</li>
<li>包装类–&gt;String：String.valueOf(包装类)</li>
<li>String–&gt;包装类：Type.parseType(String)</li>
</ul>
<p>Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]，保存了-128<del>127范围的整数，使用自动装箱时，给Integer赋值的范围在-128</del>127范围中时，直接使用数组中的元素，不再new对象，目的是为了提高效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------------------------</span><br><span class="line">UML图</span><br><span class="line">-----------------------------------------------</span><br><span class="line">Class</span><br><span class="line">-----------------------------------------------</span><br><span class="line">variable：type</span><br><span class="line">-----------------------------------------------</span><br><span class="line">method(variable：type)：return type</span><br><span class="line">-----------------------------------------------</span><br></pre></td></tr></table></figure>



<h2 id="6-9-this关键字"><a href="#6-9-this关键字" class="headerlink" title="6.9 this关键字"></a>6.9 this关键字</h2><ul>
<li><p>this.方法或属性，调用当前对象属性或方法</p>
</li>
<li><p>通常情况省略不写</p>
</li>
<li><p>this()构造器嵌套</p>
</li>
</ul>
<h2 id="6-10-super关键字"><a href="#6-10-super关键字" class="headerlink" title="6.10 super关键字"></a>6.10 super关键字</h2><p>super() super.variable super.method()<br>类构造器中this()或super()构造器只能二选一，不能同时出现</p>
<h2 id="6-11-package-import关键字"><a href="#6-11-package-import关键字" class="headerlink" title="6.11 package import关键字"></a>6.11 package import关键字</h2><p>import static：导入指定包内静态结构，落脚点是类中的结构（属性或方法）<br>&#x2F;&#x2F;import static java.lang.System.*</p>
<h2 id="6-12-final关键字"><a href="#6-12-final关键字" class="headerlink" title="6.12 final关键字"></a>6.12 final关键字</h2><ul>
<li><p>修饰：类、方法、变量</p>
</li>
<li><p>final类：不可被继承，与abstract相驳</p>
</li>
<li><p>final方法：不可被重写</p>
</li>
<li><p>final变量：此时”变量”被称为一个常量，全部常量声明为public static final CONSTANT;&#x2F;&#x2F;需要进行数值初始化</p>
</li>
<li><p>final修饰形参时方法内只能调用不能重新赋值</p>
</li>
</ul>
<h2 id="6-13-static关键字"><a href="#6-13-static关键字" class="headerlink" title="6.13 static关键字"></a>6.13 static关键字</h2><ul>
<li><p>数据在内存空间内只有一份</p>
</li>
<li><p>可以修饰：属性、方法、代码块、内部类</p>
</li>
<li><p>静态变量|类变量：内存内只有一个共享的静态变量，存在于方法区的静态域中。</p>
</li>
<li><p>静态方法|类方法：随着类的加载而加载</p>
<ul>
<li>&#x2F;&#x2F;静态方法中只能调用静态的方法或属性，非静态方法中，既可以调用非静态方法或属性，也可以调用静态的方法或属性。常用于工具类的创建使用</li>
</ul>
</li>
<li><p>静态代码块：加载类时执行</p>
</li>
</ul>
<h2 id="6-14-代码块"><a href="#6-14-代码块" class="headerlink" title="6.14 代码块{}"></a>6.14 代码块{}</h2><ul>
<li><p>修饰：不写，static</p>
</li>
<li><p>代码块执行优先级：static{}&gt;{}&gt;constructor()</p>
</li>
<li><p>所有的父类到本类静态代码块执行完毕后执行所有的父类到本类非静态代码块，最后执行父类到本类的构造器</p>
</li>
<li><p>代码块内可以写输出语句</p>
</li>
<li><p>{}非静态代码块：随着创建对象时执行</p>
<ul>
<li>&#x2F;&#x2F;初始化类的信息</li>
</ul>
</li>
<li><p>static{}静态代码块：随着类的加载而执行</p>
<ul>
<li>&#x2F;&#x2F;初始化对象的属性</li>
</ul>
</li>
<li><p>静态代码块只能调用静态的属性或方法</p>
</li>
<li><p>非静态代码块可以调用任何属性和方法</p>
</li>
</ul>
<p>类内属性赋值优先级：默认初始化(int a)&gt;显式初始化(int a&#x3D;1;)&#x3D;&#x3D;代码块({a &#x3D; 2;})&gt;构造器初始化&gt;对象.属性</p>
<h2 id="6-15-MVC设计模式"><a href="#6-15-MVC设计模式" class="headerlink" title="6.15 MVC设计模式"></a>6.15 MVC设计模式</h2><ul>
<li><p>model数据模型层</p>
</li>
<li><p>view视图模型层</p>
</li>
<li><p>controller控制器层</p>
</li>
</ul>
<h2 id="6-16-abstract-抽象"><a href="#6-16-abstract-抽象" class="headerlink" title="6.16 abstract(抽象)"></a>6.16 abstract(抽象)</h2><ul>
<li><p>可以用来修饰的结构：类、方法</p>
</li>
<li><p>类：添加修饰符abstract</p>
<ul>
<li>&#x2F;&#x2F;不能实例化</li>
</ul>
</li>
<li><p>方法：增加修饰符abstract，删除方法体</p>
<ul>
<li>&#x2F;&#x2F;public abstract void method();</li>
<li>&#x2F;&#x2F;抽象类中可以没有抽象方法</li>
<li>&#x2F;&#x2F;不能用来修饰私有方法、静态方法、final声明的方法</li>
<li>&#x2F;&#x2F;与平常类相似，增加了可以不写方法体的方法，子类需要重写实现抽象方法才可以写成普通类</li>
<li>&#x2F;&#x2F;抽象类实现自己时对构造器添加方法体进行重写方法，相当于是创建了一个匿名类对象</li>
</ul>
</li>
</ul>
<h2 id="6-17-interface-接口"><a href="#6-17-interface-接口" class="headerlink" title="6.17 interface(接口)"></a>6.17 interface(接口)</h2><ul>
<li><p>可以实现多重继承，即多实现implements</p>
</li>
<li><p>让一个类或接口具备多个功能,实现了多态性</p>
</li>
<li><p>全局常量：public static final</p>
</li>
<li><p>抽象方法：public abstract</p>
<ul>
<li>&#x2F;&#x2F;声明默认可省略</li>
</ul>
</li>
<li><p>jdk7及以前：只能定义全局常量和抽象方法</p>
</li>
<li><p>jdk8：可以定义静态方法static、默认方法default</p>
</li>
<li><p>jdk9及以后：可以定义私有方法private</p>
<ul>
<li>&#x2F;&#x2F;接口体现就是定义了一种规范，在一个接口内声明必须实现的方法</li>
<li>&#x2F;&#x2F;接口中定义的静态方法只能通过接口调用</li>
<li>&#x2F;&#x2F;如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数的方法–&gt;类优先原则</li>
<li>&#x2F;&#x2F;类实现了多个接口，多个类中定义了同名同参数的默认方法，实现类在没有重写此方法的情况下会报错。–&gt;接口冲突</li>
<li>&#x2F;&#x2F;直接调用接口中的默认方法：Interface.super.defaultMethod();</li>
</ul>
</li>
</ul>
<h2 id="6-18-内部类"><a href="#6-18-内部类" class="headerlink" title="6.18 内部类"></a>6.18 内部类</h2><p>分类：成员内部类、局部内部类(方法内，代码块内，构造器内)<br><strong>成员内部类</strong></p>
<ul>
<li>修饰符：缺省，static静态</li>
<li>可以被final,abstract修饰</li>
<li>成员内部类调用外部类的非静态属性：[Class.this.]method();</li>
</ul>
<p><strong>成员内部类的创建</strong></p>
<ul>
<li>静态内部类：Class.inner in &#x3D; new Class.inner();</li>
<li>非静态内部类：Class.inner in &#x3D; new Class().inner();</li>
</ul>
<h2 id="6-19-枚举类enum"><a href="#6-19-枚举类enum" class="headerlink" title="6.19 枚举类enum"></a>6.19 枚举类enum</h2><p><strong>jdk5前</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">final</span> <span class="variable">enumClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnumClass</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>jdk5.0出现enum关键字定义枚举类</p>
</li>
<li><p>使用：定义一组常量时，使用枚举类</p>
</li>
<li><p>枚举类的定义：有限的，确定的类对象</p>
<ul>
<li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式</li>
</ul>
</li>
</ul>
<p><strong>定义枚举类</strong></p>
<ul>
<li><p>定义时：对象之间用’,’分隔，结尾用’;’结束  </p>
</li>
<li><p>不重写toString方法时，sout输出为枚举对象名</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line">Class Season&#123;</span><br><span class="line">    <span class="comment">//定义枚举类对象的属性</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Stirng seasonName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="comment">//给枚举对象赋值</span></span><br><span class="line">	Seanson(String seasonName,String seasonDesc)&#123;</span><br><span class="line">		<span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">		<span class="built_in">this</span>.seasonDesc = seasonName;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//枚举类的对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//提供get方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写toString()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//enum定义枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//对象提到最前方，对象之间用&#x27;,&#x27;分隔，结尾用&#x27;;&#x27;结束</span></span><br><span class="line">    PRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)[,...];</span><br><span class="line">    <span class="comment">//定义枚举类对象的属性</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Stirng seasonName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="comment">//提供get方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写toString()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong></p>
<ul>
<li><p>Enum[] values() </p>
<ul>
<li>返回枚举类的对象(常量)数组</li>
</ul>
</li>
<li><p>Enum valueOf(String str) </p>
<ul>
<li>根据str名找到枚举类的对象名，并返回枚举对象</li>
</ul>
</li>
<li><p>toString() </p>
<ul>
<li>不重写toString方法时输出枚举对象名</li>
</ul>
</li>
<li><p>枚举可实现interface接口</p>
<ul>
<li><p>方法一：与普通类相同，在enum类中实现抽象方法</p>
</li>
<li><p>方法二：在枚举类定义时分别实现接口中的抽象方法</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//enum定义枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">//对象提到最前方，对象之间用&#x27;,&#x27;分隔，结尾用&#x27;;&#x27;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;[,...];</span><br><span class="line">    <span class="comment">//定义枚举类对象的属性</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Stirng seasonName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    <span class="comment">//提供get方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用Switch</strong></p>
<p>&#x2F;&#x2F;声明对象时用Enum.枚举对象，调switch时直接使用枚举对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span>&#123;</span><br><span class="line">    FREE,BUSY,VOCATION;</span><br><span class="line">&#125;</span><br><span class="line">psvm&#123;</span><br><span class="line">   	<span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> Status.FREE;</span><br><span class="line">    <span class="keyword">switch</span>(status)&#123;</span><br><span class="line">    	<span class="keyword">case</span> FREE：...</span><br><span class="line">        <span class="keyword">case</span> BUSY：...</span><br><span class="line">        <span class="keyword">case</span> VOCATION：...</span><br><span class="line">        <span class="keyword">default</span>：</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="七、JUnit4"><a href="#七、JUnit4" class="headerlink" title="七、JUnit4"></a>七、JUnit4</h1><ul>
<li>1.写Test类</li>
<li>2.类内写普通方法</li>
<li>3.方法上添加@Test注解<ul>
<li>没异常绿，有异常红</li>
</ul>
</li>
</ul>
<p><strong>@Test</strong></p>
<ul>
<li><p>调用测试方法前后使用：</p>
</li>
<li><p>实例方法：@Before @After</p>
</li>
<li><p>静态方法：@BeforeClass @AfterClass</p>
</li>
</ul>
<h1 id="八、Annotation注解"><a href="#八、Annotation注解" class="headerlink" title="八、Annotation注解"></a>八、Annotation注解</h1><p><strong>JDK5.0新增</strong></p>
<p>代码里面的特殊标记，可以在编译，类加载，运行时被读取，并执行相应的处理</p>
<p>实用：配置切面，代替xml配置</p>
<p><strong>框架&#x3D;注解+反射+设计模式</strong></p>
<h2 id="8-1-常用Annotation"><a href="#8-1-常用Annotation" class="headerlink" title="8.1 常用Annotation"></a>8.1 常用Annotation</h2><h3 id="8-1-1-文档相关"><a href="#8-1-1-文档相关" class="headerlink" title="8.1.1 文档相关"></a>8.1.1 文档相关</h3><ul>
<li><p>@author标明开发该模块作者，多个作者之间使用’,’分隔</p>
</li>
<li><p>@version标明该模块的版本</p>
</li>
<li><p>@since哪个版本开始</p>
</li>
<li><p>@param方法参数说明</p>
</li>
<li><p>@return方法返回值说明</p>
</li>
<li><p>@exception方法抛出异常说明</p>
</li>
</ul>
<h3 id="8-1-2-编译时格式检查"><a href="#8-1-2-编译时格式检查" class="headerlink" title="8.1.2 编译时格式检查"></a>8.1.2 编译时格式检查</h3><ul>
<li><p>@Override重写：限定重写父类方法</p>
</li>
<li><p>@deprecated弃用：标识所修饰元素(类、方法等)已过时</p>
</li>
<li><p>@SuppressWarings抑制警告：抑制警告编译器</p>
</li>
</ul>
<h3 id="8-1-3-注解的使用"><a href="#8-1-3-注解的使用" class="headerlink" title="8.1.3 注解的使用"></a>8.1.3 注解的使用</h3><ul>
<li><p>无参数</p>
</li>
<li><p>单参数(“”)</p>
</li>
<li><p>多参数({“”,””})</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未使用的变量上添加SuppressWarings注解</span></span><br><span class="line"><span class="meta">@SuppressWarings(&quot;unused&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-4-自定义注解"><a href="#8-1-4-自定义注解" class="headerlink" title="8.1.4 自定义注解"></a>8.1.4 自定义注解</h3><ul>
<li><p>注解声明为：@interface</p>
</li>
<li><p>内部定义成员，通常使用value标识</p>
</li>
<li><p>都会指定两个元注解：Retention、Target</p>
</li>
<li><p>可以指定成员的默认值，使用default定义</p>
</li>
<li><p>如果自定义注解没有成员，表明是一个标识作用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="comment">//当定义default属性时，注解使用可忽略属性赋值@MyAnnotation直接调用</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;person&quot;</span>;</span><br><span class="line">    <span class="comment">//String[] value();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用注解</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-5-元注解"><a href="#8-1-5-元注解" class="headerlink" title="8.1.5 元注解"></a>8.1.5 元注解</h3><p>元Annotation用于修饰其他Annotation定义</p>
<p><strong>JDK5.0提供了四个标准类型</strong></p>
<ul>
<li><p>(1)Retention：指定生命周期</p>
<ul>
<li><p>&#x2F;&#x2F;生命周期：SOURCE CLASS RUNTIME</p>
</li>
<li><p>&#x2F;&#x2F;@Retention(RetentionPolicy.SOURCE)</p>
</li>
<li><p>&#x2F;&#x2F;只有被声明为RUNTIME生命周期的注解才能通过反射获取</p>
</li>
</ul>
</li>
<li><p>(2)Target：指定被修饰Annotation能用于修饰哪些程序元素</p>
<ul>
<li>&#x2F;&#x2F;@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE})</li>
</ul>
</li>
<li><p>(3)Dcoumented：被修饰的Annotation类将被javadoc提取成文档</p>
</li>
<li><p>(4)Inherited：被修饰的Annotation将具有继承性，如果某个类使用了该注解，继承的子类自动具有该注解</p>
<ul>
<li><p>元数据理解：String name &#x3D; “bamboo”</p>
</li>
<li><p>&#x2F;&#x2F;最重要的是”bamboo”，String name对现有数据进行修饰，String name就是元注解</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-1-6-反射获取注解"><a href="#8-1-6-反射获取注解" class="headerlink" title="8.1.6 反射获取注解"></a>8.1.6 反射获取注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">method()&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.class;</span><br><span class="line">    Annotation[] annotations = clazz.getAnnotation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-7-JDK8新增可重复注解，类型注解"><a href="#8-1-7-JDK8新增可重复注解，类型注解" class="headerlink" title="8.1.7 JDK8新增可重复注解，类型注解"></a>8.1.7 JDK8新增可重复注解，类型注解</h3><p>@Repeatable(Annotation.class)</p>
<h1 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h1><p>代码结构，编程风格以及解决问题的思考方式</p>
<h2 id="9-1-单例模式-singleton"><a href="#9-1-单例模式-singleton" class="headerlink" title="9.1 单例模式(singleton)"></a>9.1 单例模式(singleton)</h2><p>采取一定方式保证在整个系统中对某个类只有一个对象实例</p>
<h3 id="9-1-1-饿汉模式"><a href="#9-1-1-饿汉模式" class="headerlink" title="9.1.1 饿汉模式"></a>9.1.1 饿汉模式</h3><ol>
<li><p>私有化构造器</p>
</li>
<li><p>私有化一个instance的static对象并进行new分配内存&#x2F;&#x2F;private Class instance &#x3D; new Class();</p>
</li>
<li><p>公共静态方法getInstance()返回类对象，return instance;</p>
</li>
</ol>
<h3 id="9-1-2-懒汉模式-延迟构造"><a href="#9-1-2-懒汉模式-延迟构造" class="headerlink" title="9.1.2 懒汉模式(延迟构造)"></a>9.1.2 懒汉模式(延迟构造)</h3><p>&#x2F;&#x2F;线程不安全,方法增加synchronized称为安全线程</p>
<ol>
<li>私有化构造器</li>
<li>私有化一个instance的static对象，不进行new分配内存&#x2F;&#x2F;private Class instance &#x3D; null;</li>
<li>公共静态方法getInstance()返回类对象，return instance;&#x2F;&#x2F;其中增加判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="title class_">Class</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全的懒汉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Class</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Class <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//此时锁是Class.class，此时为静态同步方法的锁</span></span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//会出现线程阻塞的地方</span></span><br><span class="line">    	instance = <span class="keyword">new</span> <span class="title class_">Class</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或是</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Class</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Class.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        	<span class="comment">//会出现线程阻塞的地方</span></span><br><span class="line">    		instance = <span class="keyword">new</span> <span class="title class_">Class</span>();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-2-模板方法模式-TemplateMethod"><a href="#9-2-模板方法模式-TemplateMethod" class="headerlink" title="9.2 模板方法模式(TemplateMethod)"></a>9.2 模板方法模式(TemplateMethod)</h2><p>实现某一算法时，步骤很固定通用，父类已经写好的，但某部分易变，易变部分可以抽象出来，供不同的子类实现<br>固定通用部分方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//final修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">methodName</span><span class="params">()</span>&#123;</span><br><span class="line">	......</span><br><span class="line">	inconstancy();<span class="comment">//钩子方法，回调方法</span></span><br><span class="line">	......	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象出来的易变部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//abstract修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">inconstancy</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h2 id="9-3-代理模式-Proxy"><a href="#9-3-代理模式-Proxy" class="headerlink" title="9.3 代理模式(Proxy)"></a>9.3 代理模式(Proxy)</h2><h2 id="9-4-工厂设计模式-Factory"><a href="#9-4-工厂设计模式-Factory" class="headerlink" title="9.4 工厂设计模式(Factory)"></a>9.4 工厂设计模式(Factory)</h2><p>创建者和调用者分离<br>]</p>
<p>main方法[<br>main内可以对args进行分配内存&#x2F;&#x2F;args&#x3D;new String[num];<br>或是通过外部Class.main调用静态main方法进行放入String类型的数组进行使用。<br>run Configuration中设置args变量，使用空格分割<br>或是控制台java Class “test1” “test2”<br>]</p>
<h1 id="十、classpath说明"><a href="#十、classpath说明" class="headerlink" title="十、classpath说明"></a>十、classpath说明</h1><p><strong>编译前</strong>文件路径寻找</p>
<ul>
<li>类.class.getResource(“”).getPath()</li>
<li>对象.getClass().getResource(“”).getPath()</li>
</ul>
<p><strong>编译后</strong>class文件路径寻找：</p>
<ul>
<li>类.class.getClassLoader().getResource(“”).getPath()</li>
<li>对象.getClass().getClassLoader().getResource(“”).getPath()</li>
</ul>
<h1 id="十一、异常处理Exception"><a href="#十一、异常处理Exception" class="headerlink" title="十一、异常处理Exception"></a>十一、异常处理Exception</h1><p>异常Throwable事件分两类：Error，Exception</p>
<h2 id="11-1-Error"><a href="#11-1-Error" class="headerlink" title="11.1 Error"></a>11.1 Error</h2><p>JVM都无法解决的严重问题，JVM内部错误，资源耗尽等严重情况。</p>
<p>OutOfMemoryError堆溢出</p>
<h2 id="11-2-Exception"><a href="#11-2-Exception" class="headerlink" title="11.2 Exception"></a>11.2 Exception</h2><p>运行时java异常</p>
<h3 id="11-2-1-RuntimeException"><a href="#11-2-1-RuntimeException" class="headerlink" title="11.2.1 RuntimeException"></a>11.2.1 RuntimeException</h3><p>运行时异常：非受检异常，直接编译略过</p>
<p><strong>常见异常</strong></p>
<ul>
<li><p>NullPointerException</p>
</li>
<li><p>ArrayIndexOutOfBoundsException</p>
</li>
<li><p>ClassCastException</p>
</li>
<li><p>NumberFormatException</p>
</li>
<li><p>InputMismatchException</p>
</li>
<li><p>ArithmeticException</p>
</li>
</ul>
<h3 id="11-2-2-编译时javac异常"><a href="#11-2-2-编译时javac异常" class="headerlink" title="11.2.2 编译时javac异常"></a>11.2.2 编译时javac异常</h3><p>受检异常，进行异常捕获,最理想是在编译期间捕获</p>
<p>常见异常</p>
<ul>
<li><p>IOException</p>
</li>
<li><p>FileNotFoundException</p>
</li>
<li><p>ClassNotFoundException</p>
</li>
</ul>
<h3 id="11-2-3-异常处理"><a href="#11-2-3-异常处理" class="headerlink" title="11.2.3 异常处理"></a>11.2.3 异常处理</h3><ul>
<li><p>(1) try-catch-finally</p>
</li>
<li><p>(2) throws Exception</p>
<ul>
<li><p>方法内使用(2)进行抛出异常，main方法中使用(1)进行捕获异常</p>
</li>
<li><p>catch内抛出调用方法</p>
</li>
<li><p>getMessage()</p>
</li>
<li><p>e.printStackTrace()  &#x2F;&#x2F;常用</p>
</li>
</ul>
</li>
</ul>
<h3 id="11-2-4-finally"><a href="#11-2-4-finally" class="headerlink" title="11.2.4 finally"></a>11.2.4 finally</h3><ul>
<li><p>关键字可选</p>
</li>
<li><p>finally声明是一定会被执行的</p>
</li>
<li><p>finally一定会执行，如果其中有return语句，则先执行finally后执行return语句，finally{return;}</p>
</li>
</ul>
<h3 id="11-2-5-throws"><a href="#11-2-5-throws" class="headerlink" title="11.2.5 throws"></a>11.2.5 throws</h3><ul>
<li><p>用法：throws 异常类</p>
</li>
<li><p>子类继承父类的throws异常类，只能是父类的异常子类，父类如果没有抛出异常，子类也不能抛出异常</p>
</li>
</ul>
<h3 id="11-2-6-throw"><a href="#11-2-6-throw" class="headerlink" title="11.2.6 throw"></a>11.2.6 throw</h3><ul>
<li>方法内throw new 异常类Exception(“message”)&#x2F;&#x2F;手动抛出异常，使用throws抛出至上级</li>
</ul>
<h3 id="11-2-7-自定义异常"><a href="#11-2-7-自定义异常" class="headerlink" title="11.2.7 自定义异常"></a>11.2.7 自定义异常</h3><p>继承Exception或RuntimeException</p>
<p>定义一个static final long serialVersionUID</p>
<p>定义有参，无参构造器，有参构造器内super(message)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumericalFaultException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1111111111111112111L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumericalFaultException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumericalFaultException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.将异常用被检测方法中抛出并填写参数内提示信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">    <span class="keyword">throws</span> NumericalFaultException &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">120</span> || age &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumericalFaultException</span>(<span class="string">&quot;年龄输入错误。&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.调用方法时捕获异常</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    stu.setAge(-<span class="number">20</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumericalFaultException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//System.out.println(e.getMessage());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二、多线程"><a href="#十二、多线程" class="headerlink" title="十二、多线程"></a>十二、多线程</h1><ul>
<li><p>线程创建方式：四种</p>
</li>
<li><p>线程同步方式：三种</p>
</li>
</ul>
<h2 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h2><ul>
<li><p>程序program：一段静态的代码</p>
</li>
<li><p>进程process：程序的一次执行过程，正在运行的一个程序</p>
</li>
<li><p>线程thread：进程进一步细化为线程，一个程序内部的一条执行路径</p>
</li>
<li><p>并发：一个CPU同时执行多个任务</p>
</li>
<li><p>并行：多个CPU同时执行多个任务</p>
</li>
</ul>
<h2 id="12-2-线程的分类"><a href="#12-2-线程的分类" class="headerlink" title="12.2 线程的分类"></a>12.2 线程的分类</h2><p>1.守护线程：服务用户线程，可以通过在start()方法前调用thread.setDaemon(true)将用户线程变成守护线程，例如java垃圾回收，若JVM中都是守护线程，则当前JVM将退出</p>
<p>2.用户线程</p>
<h2 id="12-3-Thread"><a href="#12-3-Thread" class="headerlink" title="12.3 Thread"></a>12.3 Thread</h2><h3 id="12-3-1-常用方法"><a href="#12-3-1-常用方法" class="headerlink" title="12.3.1 常用方法"></a>12.3.1 常用方法</h3><ul>
<li><p>start()：启动当前线程，调用当前线程的run()</p>
</li>
<li><p>run()：重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p>
</li>
<li><p>currentThread()：静态方法，返回执行当前代码的线程&#x2F;&#x2F;Thread.currentThread()</p>
</li>
<li><p>getName()：获取当前线程的名字&#x2F;&#x2F;Thread.currentThread().getName()或thread().getName()</p>
</li>
<li><p>setName()：设置当前线程的名字&#x2F;&#x2F;thread.setName()</p>
</li>
<li><p>yield()：线程类内调用，释放当前线程CPU的执行，供给其他线程使用，可能即刻此线程被调用&#x2F;&#x2F;this.yield();‘this’可省略</p>
</li>
<li><p>join()：线程对象调用，将其他线程直接加入当前线程中执行&#x2F;&#x2F;a线程中调用线程b的join()，此时a线程进入阻塞状态，直到b线程执行完毕，才会执行a线程</p>
</li>
<li><p>stop()：强制结束线程，不被建议使用，过时</p>
</li>
<li><p>sleep(long millitime)：休眠指定毫秒值，即当前时间内是阻塞状态</p>
</li>
<li><p>isAlive()：判断当前线程是否存活</p>
</li>
<li><p>线程通信：wait() notify() notifyAll()</p>
</li>
</ul>
<h3 id="12-3-2-构造器"><a href="#12-3-2-构造器" class="headerlink" title="12.3.2 构造器"></a>12.3.2 构造器</h3><p>new Thread子类(“Name”)给当前线程起名</p>
<h2 id="12-4-线程优先级"><a href="#12-4-线程优先级" class="headerlink" title="12.4 线程优先级"></a>12.4 线程优先级</h2><ul>
<li><p>MAX_PRIORITY：10</p>
</li>
<li><p>MIN_PRIORITY：1</p>
</li>
<li><p>NORM_PRIORITY：5 &#x2F;&#x2F;默认优先级</p>
</li>
<li><p>获取和设置线程的优先级：</p>
</li>
<li><p>getPriority()</p>
</li>
<li><p>setPriority(int p)</p>
</li>
</ul>
<p>高优先级高概率被CPU执行，不是一定被CPU先执行</p>
<h2 id="12-5-线程的创建与使用"><a href="#12-5-线程的创建与使用" class="headerlink" title="12.5 线程的创建与使用"></a>12.5 线程的创建与使用</h2><h3 id="12-5-1-方式一"><a href="#12-5-1-方式一" class="headerlink" title="12.5.1 方式一"></a>12.5.1 方式一</h3><ol>
<li><p>继承Thread类</p>
</li>
<li><p>重写Thread类的run()</p>
</li>
<li><p>创建Thread子类的对象</p>
</li>
<li><p>调用对象.start()执行线程</p>
</li>
</ol>
<p>&#x2F;&#x2F;调用run()方法执行在主线程中，不是多线程</p>
<p>&#x2F;&#x2F;start()启动线程方法只能调用一次，否则会报IllegalThreadStateException异常</p>
<h3 id="12-5-2-方式二"><a href="#12-5-2-方式二" class="headerlink" title="12.5.2 方式二"></a>12.5.2 方式二</h3><ol>
<li><p>实现Runnable接口</p>
</li>
<li><p>重写Runnable接口的run()方法</p>
</li>
<li><p>创建Runnable接口实现类的对象</p>
</li>
<li><p>将Runnable接口实现类对象添加进Thread的参数中创建对象</p>
<ul>
<li><p>&#x2F;&#x2F;new Thread(Runnable run);</p>
</li>
<li><p>&#x2F;&#x2F;new Thread(Runnable run,String threadName);</p>
</li>
</ul>
</li>
<li><p>调用start()方法</p>
<ul>
<li><p>&#x2F;&#x2F;此方式会只制造 一个Runnable对象的run所以后续Thread调用Runnable实现的run公用的是同一个地址，所以内部值唯一地址，无需使用static进行声明</p>
</li>
<li><p>&#x2F;&#x2F;Runnable天然实现了一种共享数据的情况</p>
</li>
<li><p>&#x2F;&#x2F;联系：Thread类实现了Runnable方法</p>
</li>
</ul>
</li>
</ol>
<!-- 方式二要优于方式一，开发中优先选择Runnable方式 -->

<p> <strong>方式三、四(JDK5.0)</strong></p>
<h3 id="12-5-3-方式三"><a href="#12-5-3-方式三" class="headerlink" title="12.5.3 方式三"></a>12.5.3 方式三</h3><h4 id="①-Callable接口"><a href="#①-Callable接口" class="headerlink" title="① Callable接口"></a>① Callable接口</h4><ul>
<li><p>支持泛型：当Callable指定泛型时，FutureTask也要指定泛型，否则调用get()方法需要进行强转</p>
</li>
<li><p>实现Callable接口，重写call()方法</p>
</li>
<li><p>可以有返回值，可以抛出异常，支持泛型返回值</p>
</li>
<li><p>&#x2F;&#x2F;抛出的异常调用get()时捕获</p>
</li>
<li><p>需要借助FutureTask类</p>
</li>
</ul>
<h4 id="②-Future接口"><a href="#②-Future接口" class="headerlink" title="② Future接口"></a>② Future接口</h4><ul>
<li><p>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</p>
</li>
<li><p>FutureTask同时实现了Runnable，Future接口。既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</p>
</li>
</ul>
<h4 id="③-实现线程"><a href="#③-实现线程" class="headerlink" title="③ 实现线程"></a>③ 实现线程</h4><ul>
<li><p>(1)创建线程类实现Callable接口，重写call()方法</p>
<ul>
<li>&#x2F;&#x2F;不需要返回值则return null;</li>
</ul>
</li>
<li><p>(2)创建FutureTask对象，参数填写Callable实现类</p>
</li>
<li><p>(3)创建Thread对象，参数填写FutureTask对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>(4)使用FutureTask对象的get()方法接收返回值</li>
</ul>
<h2 id="12-6-线程池"><a href="#12-6-线程池" class="headerlink" title="12.6 线程池"></a>12.6 线程池</h2><p>相关API：ExecutorService和Executors</p>
<h3 id="12-6-1-ExecutorService"><a href="#12-6-1-ExecutorService" class="headerlink" title="12.6.1 ExecutorService"></a>12.6.1 ExecutorService</h3><p>线程池接口，常见子类ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>执行任务，无返回值，一般用于执行Runnable</span><br><span class="line"></span><br><span class="line">&lt;T&gt; Future&lt;T&gt;  <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>执行任务，有返回值，一般用于执行Callable</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>关闭连接池</span><br></pre></td></tr></table></figure>



<h3 id="12-6-2-Executors"><a href="#12-6-2-Executors" class="headerlink" title="12.6.2 Executors"></a>12.6.2 Executors</h3><p>工具类，线程池的工厂类，用于创建并返回不同类型的线程池</p>
<ul>
<li><p>Executors.newCachedThreadPool()创建可根据需要创建新线程的线程池</p>
</li>
<li><p>Executors.newFixedThreadPool(n)创建可重用固定线程数的线程池</p>
</li>
<li><p>Executors.newSingleThreadExecutor()创建只有一个线程的线程池</p>
</li>
<li><p>Executors.newSchedulThreadPool(n)创建一个可以安排在给定延迟后运行命令或定期执行的线程池</p>
</li>
</ul>
<h4 id="①-线程管理"><a href="#①-线程管理" class="headerlink" title="① 线程管理"></a>① 线程管理</h4><ul>
<li><p>corePoolSize核心线程池的大小</p>
</li>
<li><p>maximumPoolSize最大线程数</p>
</li>
<li><p>keepAlivetime线程没有任务时最多保持多长时间后悔结束</p>
</li>
</ul>
<h4 id="②-实现"><a href="#②-实现" class="headerlink" title="② 实现"></a>② 实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(num);</span><br><span class="line"><span class="comment">//可选择将线程接口ExecutorService强转为线程池实现类</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor)service;</span><br><span class="line"><span class="comment">//线程池实现类设置线程池属性</span></span><br><span class="line">service1.setXXX();</span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>());</span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>());</span><br><span class="line">service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>());</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure>

<h2 id="12-7-线程的生命周期"><a href="#12-7-线程的生命周期" class="headerlink" title="12.7 线程的生命周期"></a>12.7 线程的生命周期</h2><ul>
<li><p>新建(new Thread)</p>
</li>
<li><p>-&gt;就绪(thread.start())</p>
</li>
<li><p>-&gt;运行(获取CPU的执行权后执行内部的run()，失去CPU执行权或调用yield()后返回就绪)</p>
</li>
<li><p>-&gt;阻塞(调用sleep()或wait()或join()或等待同步锁或suspend()执行后回到就绪阶段)</p>
<ul>
<li><p>&#x2F;&#x2F;等待同步锁使用获取同步锁进入就绪</p>
</li>
<li><p>&#x2F;&#x2F;wait()等待后用notify()&#x2F;notifyAll()进行唤醒进入就绪</p>
</li>
<li><p>&#x2F;&#x2F;suspned()挂起，已被弃用，resume()结束挂起进入就绪</p>
</li>
</ul>
</li>
<li><p>-&gt;死亡(调用stop()或线程执行run()方法结束或出现异常并未处理)</p>
</li>
</ul>
<h2 id="12-8-线程的同步"><a href="#12-8-线程的同步" class="headerlink" title="12.8 线程的同步"></a>12.8 线程的同步</h2><p>线程安全：多线程对某个数据的共享，会造成操作的不完整性，导致破怀数据。Java中通过同步机制来解决线程安全问题。</p>
<h3 id="12-8-1-同步代码块"><a href="#12-8-1-同步代码块" class="headerlink" title="12.8.1 同步代码块"></a>12.8.1 同步代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;<span class="comment">//常使用this为同步监视器</span></span><br><span class="line">	<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="①-说明"><a href="#①-说明" class="headerlink" title="① 说明"></a>① 说明</h4><p>操作共享的数据的代码，即为需要被同步的代码</p>
<h4 id="②-同步监视器"><a href="#②-同步监视器" class="headerlink" title="② 同步监视器"></a>② 同步监视器</h4><ul>
<li><p>俗称锁，任何一个类的对象都可以被充当锁</p>
</li>
<li><p>锁要求：多个线程必须要共用同一把锁，才能实现同步监视器的实现。</p>
</li>
</ul>
<h4 id="③-同步监视器的创建"><a href="#③-同步监视器的创建" class="headerlink" title="③ 同步监视器的创建"></a>③ 同步监视器的创建</h4><ul>
<li><p>可以使用单例singleton创建对象来给予锁</p>
</li>
<li><p>*实现Runnable接口的类的线程安全，使用this来作为同步监视器</p>
</li>
<li><p>*继承Thread类的线程安全，同步监视器可以用Class.class来代替，类class也是对象，！慎用this充当同步监视器</p>
</li>
</ul>
<h3 id="12-8-2-同步方法"><a href="#12-8-2-同步方法" class="headerlink" title="12.8.2 同步方法"></a>12.8.2 同步方法</h3><p>如果操作共享数据的代码完整的声明在一个方法中，将使用此方法声明同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runnable同步方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Type <span class="title function_">methodType</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//内部填写需要被同步的代码</span></span><br><span class="line">	<span class="comment">//Runnable同步监视器：this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Thread同步方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Type <span class="title function_">methodType</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//synchronized同步static方法</span></span><br><span class="line">    <span class="comment">//内部填写需要被同步的代码</span></span><br><span class="line">    <span class="comment">//内部调用getName()需要用Thread.currentThread()来进行静态调用</span></span><br><span class="line">    <span class="comment">//Thread同步监视器：Class.class[这是一个对象]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">	methodType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;操作代码时，只能有一个线程参与，其他线程等待。效率低下 </p>
<ul>
<li><p>实例的同步方法：同步监视器为this</p>
</li>
<li><p>静态的同步方法：同步监视器为当前类的class</p>
</li>
</ul>
<h2 id="12-9-死锁"><a href="#12-9-死锁" class="headerlink" title="12.9 死锁"></a>12.9 死锁</h2><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p>
<p>死锁只会阻塞，不会抛异常</p>
<h3 id="12-9-1-死锁演示"><a href="#12-9-1-死锁演示" class="headerlink" title="12.9.1 死锁演示"></a>12.9.1 死锁演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//死锁演示</span></span><br><span class="line">pvsm&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="comment">//死锁1</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(s1)&#123;</span><br><span class="line">                s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                s2.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(s2)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="comment">//死锁2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(s2)&#123;</span><br><span class="line">                s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                s2.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(s1)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//此方法调用后如果进入顺序为：死锁1进入s1同步锁，死锁2进入s2同步锁，死锁1等待死锁2的s2同步锁放行进入s2同步锁，死锁2等待死锁1的s1同步锁放行进入s1同步锁，此时双方都有线程阻塞，下一个同步锁被占用，导致程序无法正常执行，陷入阻塞状态无法结束运行。</span></span><br><span class="line">    <span class="comment">//如果想要此程序死锁出现的概率提高，添加sleep(long)方法即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用同步时，要避免死锁，不要同步来回调</p>
<h3 id="12-9-2-解决方法"><a href="#12-9-2-解决方法" class="headerlink" title="12.9.2 解决方法"></a>12.9.2 解决方法</h3><ul>
<li><p>专门的算法、原则</p>
</li>
<li><p>减少同步资源的定义</p>
</li>
<li><p>避免嵌套同步</p>
</li>
</ul>
<h2 id="12-10-Lock-锁"><a href="#12-10-Lock-锁" class="headerlink" title="12.10 Lock(锁)"></a>12.10 Lock(锁)</h2><ul>
<li><p>JDK5.0提供的线程同步机制，显示定义同步锁对象来实现同步</p>
</li>
<li><p>java.util.concurrent.locks.Lock接口</p>
</li>
<li><p>典型实现类ReentrantLock(可重入锁)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种锁的应用</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//Runnable使用锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//Thread使用静态锁</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在线程类中添加Lock锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//锁住线程</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//code or method</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//解锁线程</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-11-synchronized与Lock"><a href="#12-11-synchronized与Lock" class="headerlink" title="12.11 synchronized与Lock"></a>12.11 synchronized与Lock</h2><ul>
<li><p>相同点：都可解决线程安全问题</p>
</li>
<li><p>不同点：synchronized机制在执行完相应的同步代码后自动释放同步监视器。Lock需要手动的启动同步，同时手动的结束同步</p>
</li>
</ul>
<p>推荐：Lock &gt; 同步代码块 &gt; 同步方法</p>
<h2 id="12-12-sleep与wait"><a href="#12-12-sleep与wait" class="headerlink" title="12.12 sleep与wait"></a>12.12 sleep与wait</h2><ul>
<li><p>相同点</p>
<ul>
<li>一旦执行，都能使当前线程进入阻塞状态</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li><p>(1)声明位置不同，Thread.sleep()，Object.wait()</p>
</li>
<li><p>(2)使用方法不同，sleep()可以在任意场景调用，wait()必须使用在同步代码块或同步方法时调用。</p>
</li>
<li><p>(3)sleep()阻塞不释放同步监视器，wait()阻塞且释放同步监视器</p>
</li>
</ul>
</li>
</ul>
<h2 id="12-13-线程通信"><a href="#12-13-线程通信" class="headerlink" title="12.13 线程通信"></a>12.13 线程通信</h2><ul>
<li><p>wait()：执行方法后，当前线程进入阻塞状态，并释放同步监视器</p>
</li>
<li><p>notify()：执行方法后，唤醒被wait的一个线程，如果有多个线程被wait,就会唤醒优先级高的线程</p>
</li>
<li><p>notifyAll()：执行方法后，唤醒所有被wait的线程</p>
</li>
<li><p>&#x2F;&#x2F;此三项方法只能使用在同步代码块或同步方法中。</p>
</li>
<li><p>&#x2F;&#x2F;此三项方法调用者只能是同步代码块或同步方法中的同步监视器，否则会出现异常</p>
</li>
<li><p>&#x2F;&#x2F;此三项方法被定义在Object类中</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            notify();<span class="comment">//唤醒锁</span></span><br><span class="line">            <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span>+number);</span><br><span class="line">                number++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();<span class="comment">//不仅会阻塞，还会释放锁，使下一线程可以进入此安全锁</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十三、API-常用类"><a href="#十三、API-常用类" class="headerlink" title="十三、API(常用类)"></a>十三、API(常用类)</h1><h2 id="13-1-Scanner"><a href="#13-1-Scanner" class="headerlink" title="13.1 Scanner"></a>13.1 Scanner</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Scanner;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">if</span>(sc.hashNextXXX())&#123;</span><br><span class="line">	sc.nextXXX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="13-2-String"><a href="#13-2-String" class="headerlink" title="13.2 String"></a>13.2 String</h2><ul>
<li><p>不可变的字符序列，是一个final类，不可被继承</p>
</li>
<li><p>字符串是常量，值在创建后不能更改</p>
</li>
<li><p>String实现了Serialzable接口，表示字符串支持序列化</p>
</li>
<li><p>String实现了Comparable接口，表示可以比较大小</p>
</li>
<li><p>String对象的字符内容是存储在一个字符数组value[]中的，内部定义了final char[] value用于存储字符串数据</p>
</li>
<li><p>String不可变的字符序列。&#x2F;&#x2F;任何操作都不可变</p>
</li>
<li><p>&#x2F;&#x2F;使用字符串直接赋值后，使用”&#x3D;&#x3D;”进行比较会返回ture</p>
</li>
</ul>
<h3 id="13-2-1-两种赋值方式"><a href="#13-2-1-两种赋值方式" class="headerlink" title="13.2.1 两种赋值方式"></a>13.2.1 两种赋值方式</h3><ol>
<li><p>String str &#x3D; “string”;</p>
<ul>
<li><p>&#x2F;&#x2F;此方式数据声明在方法区中的字符串常量池中</p>
</li>
<li><p>&#x2F;&#x2F;此方法内容相同时”&#x3D;&#x3D;”比较为TRUE</p>
</li>
</ul>
</li>
<li><p>String str &#x3D; new String(“string”);</p>
<ul>
<li><p>&#x2F;&#x2F;此方法声明的数据保存的是地址值，数据在堆空间开辟空间后  的地址值</p>
</li>
<li><p>&#x2F;&#x2F;此方法内容相同但构造器分别声明时”&#x3D;&#x3D;”为FALSE，原因是保存的地址值</p>
</li>
</ul>
</li>
</ol>
<h3 id="13-2-2-new-String"><a href="#13-2-2-new-String" class="headerlink" title="13.2.2 new String()"></a>13.2.2 new String()</h3><p>new String(“str”)<strong>创建了两个对象</strong>：</p>
<ul>
<li><p>(1)堆空间中的new结构</p>
</li>
<li><p>(2)char[]对应的常量池中的数据”str”</p>
</li>
</ul>
<p>&#x2F;&#x2F;常量与常量的拼接结果在常量池。且常量池不会存在相同内容的常量</p>
<p>&#x2F;&#x2F;只要其中一个是变量(String类型，不论是不是newString赋值)，结果就都保存在堆中</p>
<p>&#x2F;&#x2F;如果有声明final的String字符串，则此String类型为常量，修改后仍为常量(常量保存在字符串常量池中)，与常量池中数据对比为ture</p>
<p>&#x2F;&#x2F;如果拼接的结果调用intern()方法，返回值就在常量池中</p>
<h3 id="13-2-3-字符串常量池"><a href="#13-2-3-字符串常量池" class="headerlink" title="13.2.3 字符串常量池"></a>13.2.3 字符串常量池</h3><ul>
<li><p>在方法区中存在字符串常量池</p>
</li>
<li><p>使用””赋值的数据都在字符串常量池中</p>
</li>
<li><p>在对值有所改变时(重新赋值时)，每次都会在字符串常量池中创建新的字符串地址，无法在原有位置对String类型赋值</p>
</li>
<li><p>当对现有字符串进行”+&#x3D;”连接字符串时，也会在字符串常量池中重新创建新的字符串地址</p>
</li>
</ul>
<h3 id="13-2-4-值传递"><a href="#13-2-4-值传递" class="headerlink" title="13.2.4 值传递"></a>13.2.4 值传递</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    str=<span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">psvm&#123;</span><br><span class="line">    change(str);</span><br><span class="line">    sout(str);</span><br><span class="line">    <span class="comment">//此时str为good，因值传递(此项值为地址)进入方法后，方法形参地址发生改变至字符串常量池，所以并未改变原有str变量地址的值，String不可变型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-5-常用方法"><a href="#13-2-5-常用方法" class="headerlink" title="13.2.5 常用方法"></a>13.2.5 常用方法</h3><ul>
<li><p>int length()</p>
</li>
<li><p>char charAt(int index)</p>
</li>
<li><p>boolean isEmpty()</p>
</li>
<li><p>String toLowerCase()</p>
</li>
<li><p>String toUpperCase()</p>
</li>
<li><p>String trim()忽略前后空白</p>
</li>
<li><p>boolean equals(Object obj)</p>
</li>
<li><p>boolean equalsIgnoreCase(String anotherString)</p>
</li>
<li><p>String concat(String str)等同于使用”+”连接符</p>
</li>
<li><p>int compareTo(String anotherString)</p>
</li>
<li><p>String substring(int beginIndex)</p>
</li>
<li><p>String subsring(int beginIndex,int endIndex)</p>
</li>
<li><p>boolean endWith(String suffix)</p>
</li>
<li><p>boolean startsWith(string prefix)</p>
</li>
<li><p>boolean startsWith(string prefix,int toffset)指定索引开始的子字符串是否包含此字符</p>
</li>
<li><p>boolean contains(CharSequence s)</p>
</li>
<li><p>int indexOf(String str) &#x2F;&#x2F;不存在返回-1</p>
</li>
<li><p>int lastIndexOf(String str) &#x2F;&#x2F;不存在返回-1</p>
</li>
<li><p>String replace(CharSequence target,CharSequence replacement)</p>
</li>
<li><p>replaceAll(String regex,String replacement)</p>
</li>
<li><p>boolean matches(String regex)判断是否匹配正则</p>
</li>
<li><p>String[] split(regex)分割字符串：切片</p>
</li>
<li><p>char[] toCharArray()</p>
</li>
<li><p>byte[] getBytes(“UTF-8”)&#x2F;&#x2F;编码</p>
</li>
<li><p>new String(byte[] ,”UTF-8”)&#x2F;&#x2F;解码</p>
</li>
<li><p>Type Type.parseType(String)</p>
</li>
<li><p>String.valueOf(Type type)</p>
</li>
</ul>
<h2 id="13-3-StringBuffer-StringBuilder"><a href="#13-3-StringBuffer-StringBuilder" class="headerlink" title="13.3 StringBuffer StringBuilder"></a>13.3 StringBuffer StringBuilder</h2><h3 id="13-3-1-StringBuffer可变字符序列"><a href="#13-3-1-StringBuffer可变字符序列" class="headerlink" title="13.3.1 StringBuffer可变字符序列"></a>13.3.1 StringBuffer可变字符序列</h3><p><strong>线程安全，效率低</strong></p>
<p>&#x2F;&#x2F;空参构造器制造16长度的char[]</p>
<p>&#x2F;&#x2F;扩容时扩容为原来容量的2倍数+2，同时将原有数据中的元素复制到新的数组中</p>
<p>建议使用构造器new StringBuffer(int capacity)初始化容量</p>
<h3 id="13-3-2-StringBuilder可变字符序列"><a href="#13-3-2-StringBuilder可变字符序列" class="headerlink" title="13.3.2 StringBuilder可变字符序列"></a>13.3.2 StringBuilder可变字符序列</h3><p>JDK5.0</p>
<p>可变字符序列</p>
<p><strong>未同步线程synchronized，效率高</strong></p>
<p>建议使用构造器new StringBuilder(int capacity)初始化容量</p>
<h3 id="13-3-3-常用方法"><a href="#13-3-3-常用方法" class="headerlink" title="13.3.3 常用方法"></a>13.3.3 常用方法</h3><ul>
<li><p>append(XXX)  &#x2F;&#x2F;方法链</p>
</li>
<li><p>delete(int start,int end)</p>
</li>
<li><p>replace(int start,int end,String str)指定范围内数据替换为str</p>
</li>
<li><p>insert(int offset,XXX)</p>
</li>
<li><p>reverse()</p>
</li>
<li><p>int indexOf(String str)</p>
</li>
<li><p>String substring(int start,int end)</p>
</li>
<li><p>int Length()</p>
</li>
<li><p>char charAt(int index)</p>
</li>
<li><p>setCharAt(int n,char ch)</p>
</li>
</ul>
<h2 id="13-4-Math"><a href="#13-4-Math" class="headerlink" title="13.4 Math"></a>13.4 Math</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.sqrt()</span><br><span class="line"></span><br><span class="line">Math.abs()绝对值</span><br><span class="line"></span><br><span class="line">Math.round(<span class="type">double</span>)四舍五入转为Long型</span><br><span class="line"></span><br><span class="line">Math.random()</span><br><span class="line"></span><br><span class="line"><span class="comment">//[0~1) return double</span></span><br><span class="line"><span class="comment">//公式：[a,b]：(int)(Math.random()*(b-a+1)+a)</span></span><br></pre></td></tr></table></figure>



<h2 id="13-5-BigInteger和BigDecimal"><a href="#13-5-BigInteger和BigDecimal" class="headerlink" title="13.5 BigInteger和BigDecimal"></a>13.5 BigInteger和BigDecimal</h2><p>不变的任意精度(光年也可，超过Long长度)的整数或浮点数</p>
<p><strong>构造器</strong></p>
<p>BigInteger(String val) 通用</p>
<p><strong>方法</strong></p>
<ul>
<li><p>abs() &#x2F;&#x2F;返回绝对值的BigInteger</p>
</li>
<li><p>add(BigInteger val)</p>
</li>
<li><p>subtract(BigInteger val)</p>
</li>
<li><p>multiply(BigInteger val)</p>
</li>
<li><p>divide(BigInteger val)</p>
</li>
</ul>
<p>&#x2F;&#x2F;注：参数后指定精度(int)，写静态常量，指定返回的形态，例：BigDecimal.ROUND_HALF_UP</p>
<p>pow(int exponent)返回幂次 &#x2F;&#x2F;只有整数可以是哟会给你</p>
<h2 id="13-6-Random"><a href="#13-6-Random" class="headerlink" title="13.6 Random"></a>13.6 Random</h2><p>int nextInt(num)</p>
<h2 id="13-7-Arrays"><a href="#13-7-Arrays" class="headerlink" title="13.7 Arrays"></a>13.7 Arrays</h2><p>boolean eqlaus(int[] a,int[] b)<br>String toString(int[] a)<br>void fill(int[] a,int value)将指定值填充到数组中,全部替换<br>void sort(int[] a)<br>binarySearch(int[] a ,int key)对排序后的数组进行二分法检索指定的值</p>
<p>List asList(arr[])</p>
<h2 id="13-8-System"><a href="#13-8-System" class="headerlink" title="13.8 System"></a>13.8 System</h2><p>System.exit(0)<br>System.currentTimeMillis()<br>流输出到控制台new PrintStream(System.out)</p>
<h2 id="13-9-TIME"><a href="#13-9-TIME" class="headerlink" title="13.9 TIME"></a>13.9 TIME</h2><h3 id="13-9-1-System"><a href="#13-9-1-System" class="headerlink" title="13.9.1 System"></a>13.9.1 System</h3><ul>
<li><p>System.currentTimeMillis()适用于做时间差</p>
</li>
<li><p>System.exit(int status)可以在图形化界面直接退出</p>
</li>
<li><p>System.gc()垃圾回收器</p>
</li>
<li><p>getProperty(String key)获取系统参数</p>
</li>
</ul>
<h3 id="13-9-2-Date"><a href="#13-9-2-Date" class="headerlink" title="13.9.2 Date"></a>13.9.2 Date</h3><p><strong>构造器</strong></p>
<ul>
<li>new Date()    </li>
<li>new Date(long date)</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li><p>toString()类中已经重写方法</p>
</li>
<li><p>getTime()返回当前Date对象的毫秒数(时间戳)</p>
</li>
</ul>
<p><strong>两个Date类</strong></p>
<ul>
<li><p>java.util.Date</p>
</li>
<li><p>java.sql.Date &#x2F;&#x2F;操作数据库时使用</p>
</li>
</ul>
<h3 id="13-9-3-SimpleDateFormat"><a href="#13-9-3-SimpleDateFormat" class="headerlink" title="13.9.3 SimpleDateFormat"></a>13.9.3 SimpleDateFormat</h3><p>操作：格式化为字符串，解析为日期</p>
<p>使用带参构造器：</p>
<p>new SimpleDateFormat(“yyyy-MM-dd HH：mm：ss”)</p>
<p>方法：</p>
<p>String format(Date date) &#x2F;&#x2F;格式化为字符串</p>
<p>Date parse(String date) &#x2F;&#x2F;解析为Date，字符串格式””</p>
<h3 id="13-9-4-Calendar日历类"><a href="#13-9-4-Calendar日历类" class="headerlink" title="13.9.4 Calendar日历类"></a>13.9.4 Calendar日历类</h3><p>创建对象：Calendar.getInstance()</p>
<p>静态属性：调用Calendar.XXX</p>
<p>方法：调用静态属性进行使用</p>
<ul>
<li><p>get(静态属性)</p>
</li>
<li><p>set(静态属性,value)</p>
</li>
<li><p>add(静态属性,value)</p>
</li>
<li><p>getTime()</p>
</li>
<li><p>setTime()</p>
</li>
</ul>
<h3 id="13-9-5-JDK8前面临的问题"><a href="#13-9-5-JDK8前面临的问题" class="headerlink" title="13.9.5 JDK8前面临的问题"></a>13.9.5 JDK8前面临的问题</h3><ul>
<li><p>可变性：日期时间的类应该是不可变的</p>
</li>
<li><p>偏移量：Date中年份是从1900年开始，月份是从0开始的</p>
</li>
<li><p>格式化：格式化只对Date有用，Calendar无用</p>
</li>
<li><p>线程不安全，也不能处理更小的时间单位</p>
</li>
</ul>
<h3 id="13-9-6-LocalDate-LocalTime-LocalDateTime"><a href="#13-9-6-LocalDate-LocalTime-LocalDateTime" class="headerlink" title="13.9.6 LocalDate LocalTime LocalDateTime"></a>13.9.6 LocalDate LocalTime LocalDateTime</h3><p>不可变性，修改后返回新对象，保留原始数值</p>
<p>实例化：Class.now() Class.of(year,month,day[,…])</p>
<p>方法：</p>
<ul>
<li><p>getXXX() &#x2F;&#x2F;获取</p>
</li>
<li><p>withXXX() &#x2F;&#x2F;设置</p>
</li>
<li><p>plusXXX() &#x2F;&#x2F;添加某值</p>
</li>
<li><p>minusXXX()  &#x2F;&#x2F;减去某值</p>
</li>
</ul>
<h3 id="13-9-7-Instant-瞬时"><a href="#13-9-7-Instant-瞬时" class="headerlink" title="13.9.7 Instant 瞬时"></a>13.9.7 Instant 瞬时</h3><p>用于获取时间戳，精确到纳秒级</p>
<p>创建对象：</p>
<ul>
<li>Instant.now()</li>
</ul>
<p>方法：</p>
<ul>
<li><p>instant.atOffset(ZoneOffset.ofHours(8)) &#x2F;&#x2F;调用方法设置在东八区(中国时区)</p>
</li>
<li><p>long instant.toEpochMilli() &#x2F;&#x2F;获取毫秒数</p>
</li>
</ul>
<h3 id="13-9-8-DateTimeFormatter"><a href="#13-9-8-DateTimeFormatter" class="headerlink" title="13.9.8 DateTimeFormatter"></a>13.9.8 DateTimeFormatter</h3><p>格式化或解析日期、时间</p>
<p>创建对象：</p>
<ul>
<li><p>(1) 默认格式DateTimeFormatter.ISO_LOCAL_DATE_TIME</p>
</li>
<li><p>(2) 固定格式DateTimeFormatter.ofLocalizedDateTime(FormatStyle.XXX)</p>
</li>
<li><p>(3) 自定义格式DateTimeFormatter.ofPattern(“yyyy-MM-dd HH：mm：ss”)</p>
</li>
</ul>
<p>方法：</p>
<ul>
<li><p>String format(LocalDateTime) &#x2F;&#x2F;参数为jdk8新增的三个日期时间类</p>
</li>
<li><p>TemporalAccessor parse(String date) &#x2F;&#x2F;解析为日期</p>
</li>
</ul>
<h2 id="13-10-Object"><a href="#13-10-Object" class="headerlink" title="13.10 Object"></a>13.10 Object</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">equals() hashCode() toString() clone() finalize() wait() notify() notifyAll() getClass()</span><br><span class="line">    </span><br><span class="line">x.equals(<span class="literal">null</span>)==&gt;<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"><span class="literal">null</span>.equals(x)==&gt;NullPointerException</span><br><span class="line"><span class="string">&quot;==&quot;</span>符号使用时必须保证两边类型一致</span><br><span class="line"><span class="string">&quot;a&quot;</span>==<span class="string">&quot;a&quot;</span>==&gt;<span class="literal">true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>)==<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>)==&gt;<span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h2 id="13-11-比较器"><a href="#13-11-比较器" class="headerlink" title="13.11 比较器"></a>13.11 比较器</h2><p>Double.compare(obj1,obj2);</p>
<h3 id="13-11-1-Comparable接口-自然排序"><a href="#13-11-1-Comparable接口-自然排序" class="headerlink" title="13.11.1 Comparable接口(自然排序)"></a>13.11.1 Comparable接口(自然排序)</h3><p>实现此接口的对象的列表（和数组）可以由Collections.sort和Arrays.sort自动排序</p>
<p>重写compareTo(obj)</p>
<ul>
<li><p>如果当前对象this大于形参对象obj，则返回正整数</p>
</li>
<li><p>如果当前对象this小于形参对象obj，则返回负整数</p>
</li>
<li><p>如果当前对象this等于形参对象obj，则返回零</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在compareTo(obj)中进行自然排序</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Class)&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">class</span> <span class="operator">=</span> (Class)o;</span><br><span class="line">        <span class="comment">//默认升序</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.XXX &gt; class.XXX)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.XXX &lt; class.XXX)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-11-2-Comparator接口-定制排序"><a href="#13-11-2-Comparator接口-定制排序" class="headerlink" title="13.11.2 Comparator接口(定制排序)"></a>13.11.2 Comparator接口(定制排序)</h3><p>可以将接口多态写出来进行使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1,Object o2)</span>&#123;</span><br><span class="line">		<span class="comment">//.....</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(arr,com);</span><br></pre></td></tr></table></figure>

<p>重写compare(Object o1,Object o2)方法</p>
<p>返回正整数表示o1大于o2</p>
<p>返回0表示相等</p>
<p>返回负整数表示o1小于o2</p>
<p>使用：Arrays.sort(arr , Comparator comparator)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1,Object o2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Class &amp;&amp; o2 <span class="keyword">instanceof</span> Class)&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> (Class)o1;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> (Class)o2;</span><br><span class="line">        <span class="keyword">return</span> c1.compareTo(c2);</span><br><span class="line">        <span class="comment">//如果需要降序排序，则在return上添加&#x27;-&#x27;号进行颠倒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-11-3-对比"><a href="#13-11-3-对比" class="headerlink" title="13.11.3 对比"></a>13.11.3 对比</h3><p>Comparable接口一旦实现则固定，Comparator接口属于临时性的比较。</p>
<h3 id="13-11-4-比较器实现"><a href="#13-11-4-比较器实现" class="headerlink" title="13.11.4 比较器实现"></a>13.11.4 比较器实现</h3><p>实现对自定义排序的数据进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建数组类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;</span><br><span class="line"><span class="comment">//数组类内创建不可变List集合存储数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; COMPARE_STR =</span><br><span class="line">            Arrays.asList(<span class="string">&quot;integer&quot;</span>, <span class="string">&quot;long&quot;</span>, <span class="string">&quot;float&quot;</span>, <span class="string">&quot;double&quot;</span>, <span class="string">&quot;index&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;select&quot;</span>, <span class="string">&quot;delete&quot;</span>);</span><br><span class="line"><span class="comment">//重写compareTo方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">    <span class="comment">//使用List数组的方法indexOf确认索引下标，进行相减操作</span></span><br><span class="line">    <span class="keyword">return</span> -(COMPARE_STR.indexOf(<span class="built_in">this</span>.getName())-COMPARE_STR.indexOf(o.getName()));</span><br><span class="line">	<span class="comment">//默认升序排序，如将结果取负，则为降序排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用时对类数组进行Arrays排序</span></span><br><span class="line">Arrays.sort(students);<span class="comment">//此时students是一个数组对象</span></span><br><span class="line"><span class="comment">//调Arrays.toString(students)，Student类需要被重写toString方法</span></span><br><span class="line">System.out.println(Arrays.toString(students));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	以下为结果</span></span><br><span class="line"><span class="comment">	原赋值数组数据：1：delete 21	2：float 66	3：long 33	4：index 77	5：long 86	</span></span><br><span class="line"><span class="comment">	排序后数组数据顺序(降序排序)：</span></span><br><span class="line"><span class="comment">		[Student&#123;name=&#x27;delete&#x27;, age=21&#125;, </span></span><br><span class="line"><span class="comment">		 Student&#123;name=&#x27;index&#x27;, age=77&#125;, </span></span><br><span class="line"><span class="comment">		 Student&#123;name=&#x27;float&#x27;, age=66&#125;, </span></span><br><span class="line"><span class="comment">		 Student&#123;name=&#x27;long&#x27;, age=33&#125;, </span></span><br><span class="line"><span class="comment">		 Student&#123;name=&#x27;long&#x27;, age=86&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="十四、集合"><a href="#十四、集合" class="headerlink" title="十四、集合"></a>十四、集合</h1><ul>
<li><p>Array存储对象具有弊端，集合是一个动态的存储数据的容器</p>
</li>
<li><p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器</p>
</li>
<li><p>说明：此时存储是在内存层面的存储，不涉及到持久化(.txt,.jpg,.avi,数据库)存储</p>
</li>
</ul>
<h2 id="14-1-数组与集合的对比"><a href="#14-1-数组与集合的对比" class="headerlink" title="14.1 数组与集合的对比"></a>14.1 数组与集合的对比</h2><p>数组：</p>
<ul>
<li><p>有序，可重复</p>
</li>
<li><p>只有arr.length可用，没有现成的属性和方法可用</p>
</li>
<li><p>初始化后长度确定，长度不可修改</p>
</li>
</ul>
<p>集合：Collection体系和Map体系</p>
<h2 id="14-2-概述"><a href="#14-2-概述" class="headerlink" title="14.2 概述"></a>14.2 概述</h2><ul>
<li><p>Collection接口，Map接口</p>
</li>
<li><p>单列数据与键值对数据</p>
</li>
</ul>
<h2 id="14-3-关系"><a href="#14-3-关系" class="headerlink" title="14.3 关系"></a>14.3 关系</h2><ul>
<li><p>Collection</p>
<ul>
<li>List</li>
<li>Set</li>
</ul>
</li>
<li><p>List：有序可重复</p>
<ul>
<li>Vector</li>
<li>ArrayList</li>
<li>LinkedList</li>
</ul>
</li>
<li><p>Set：无序不可重复</p>
<ul>
<li>HashSet <ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>TreeSet</li>
</ul>
</li>
<li><p>Map：一一对应</p>
</li>
<li><p>Hashtable </p>
</li>
<li><p>HashMap </p>
<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li><p>TreeMap</p>
</li>
<li><p>Hashtable</p>
<ul>
<li>Properties</li>
</ul>
</li>
</ul>
<p>对象排序接口：</p>
<ul>
<li>Comparable </li>
<li>Comparator</li>
</ul>
<p>容器工具类：Collections</p>
<p>迭代器：Iterator</p>
<h2 id="14-4-Collection接口"><a href="#14-4-Collection接口" class="headerlink" title="14.4 Collection接口"></a>14.4 Collection接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong>：</p>
<ul>
<li><p>add(E e) addAll(Collection c)</p>
</li>
<li><p>remove(“”) removeAll(Collection coll)</p>
</li>
<li><p>retainAll(Collection coll) &#x2F;&#x2F;将两者的交集保存，其他的删除</p>
</li>
<li><p>int size()</p>
</li>
<li><p>isEmpty() &#x2F;&#x2F;返回size&#x3D;&#x3D;0，内容为空，不是指针为空</p>
</li>
<li><p>clear()</p>
</li>
<li><p>boolean contains(“”) &#x2F;&#x2F;判断是否存在，内部调用equals进行对比</p>
</li>
<li><p>boolean containsAll(Collection coll)</p>
</li>
<li><p>hashCode()</p>
</li>
<li><p>toArray()</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">集合：Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br></pre></td></tr></table></figure>

<p>Iterator iterator() &#x2F;&#x2F;返回此接口，用于遍历</p>
<p>forEach(方法引用) &#x2F;&#x2F;用于遍历</p>
<h2 id="14-5-List接口"><a href="#14-5-List接口" class="headerlink" title="14.5 List接口"></a>14.5 List接口</h2><p>元素有序、且可重复</p>
<p>常用实现类：ArrayList、LinedList、Vector</p>
<ul>
<li><p>相同点：三个实现类都实现了List接口，存储数据特点相同，存储有序，可重复数据</p>
</li>
<li><p>不同点：</p>
<ul>
<li><p>ArrayList：主要实现类，线程不安全，效率高，使用Object[] elementData存储</p>
</li>
<li><p>LinkedList：对于频繁插入、删除操作，使用此类效率比ArrayList效率高，底层使用双向链表存储</p>
</li>
<li><p>Vector：古老实现类，线程安全，效率低</p>
</li>
</ul>
</li>
</ul>
<h3 id="14-5-1-常用方法"><a href="#14-5-1-常用方法" class="headerlink" title="14.5.1 常用方法"></a>14.5.1 常用方法</h3><ul>
<li><p>add(int index,Object ele)</p>
</li>
<li><p>addAll(int index,Collection eles)</p>
</li>
<li><p>Object get(int index)</p>
</li>
<li><p>int indexOf(Object obj)</p>
</li>
<li><p>int lastIndexOf(Object obj)</p>
</li>
<li><p>Object remove(int index) remove(Object obj)</p>
</li>
<li><p>Object set(int index,Objec ele)</p>
</li>
<li><p>List subList(int fromIndex,int toIndex)  &#x2F;&#x2F;返回此位置的子集合</p>
</li>
</ul>
<h3 id="14-5-2-ArrayList"><a href="#14-5-2-ArrayList" class="headerlink" title="14.5.2 ArrayList"></a>14.5.2 ArrayList</h3><p>jdk7建议开发时使用带参构造器new ArrayList( int capacity)设置初始值</p>
<p>jdk8中new ArrayList()创建的{}</p>
<p><strong>如调用remove(?)方法，当?是数字时，认为?是一个索引，使用new Integer(?)才为对象</strong></p>
<h4 id="①-循环"><a href="#①-循环" class="headerlink" title="① 循环"></a>① 循环</h4><ol>
<li><p>Iterator迭代器</p>
</li>
<li><p>增强foreach</p>
</li>
<li><p>普通for循环</p>
</li>
<li><p>stream循环</p>
</li>
<li><p>forEach(方法引用)循环</p>
</li>
</ol>
<h3 id="14-5-3-LinkedList"><a href="#14-5-3-LinkedList" class="headerlink" title="14.5.3 LinkedList"></a>14.5.3 LinkedList</h3><p>new LinedList()内部声明了Node类型的first和last属性，默认为null</p>
<h3 id="14-5-4-Vector"><a href="#14-5-4-Vector" class="headerlink" title="14.5.4 Vector"></a>14.5.4 Vector</h3><p>已不使用，可使用下列方式进行线程安全操作</p>
<p>使用Collections.synchronizedList(List list)返回一个线程安全</p>
<h2 id="14-6-Set接口"><a href="#14-6-Set接口" class="headerlink" title="14.6 Set接口"></a>14.6 Set接口</h2><p>无序的，不可重复的</p>
<ul>
<li><p>HashSet：主要实现类，线程不安全，可以存储null值</p>
</li>
<li><p>LinkedHashSet：HashSet的子类，遍历时按照添加的循序遍历</p>
</li>
<li><p>TreeSet：可以按照添加对象的指定属性进行排序</p>
</li>
</ul>
<h3 id="14-6-1-常用方法"><a href="#14-6-1-常用方法" class="headerlink" title="14.6.1 常用方法"></a>14.6.1 常用方法</h3><p>无可用扩充方法，方法继承于Collection接口</p>
<h3 id="14-6-2-无序性说明"><a href="#14-6-2-无序性说明" class="headerlink" title="14.6.2 无序性说明"></a>14.6.2 无序性说明</h3><p>根据数据的hashCode进行排序，而不是乱序</p>
<h3 id="14-6-3-不可重复性说明"><a href="#14-6-3-不可重复性说明" class="headerlink" title="14.6.3 不可重复性说明"></a>14.6.3 不可重复性说明</h3><p>添加元素时先通过hashcode判断，再按照equals判断</p>
<h3 id="14-6-4-hashCode-与-equals"><a href="#14-6-4-hashCode-与-equals" class="headerlink" title="14.6.4 hashCode 与 equals"></a>14.6.4 hashCode 与 equals</h3><p>重写的条件尽可能相等</p>
<h3 id="14-6-5-HashSet"><a href="#14-6-5-HashSet" class="headerlink" title="14.6.5 HashSet"></a>14.6.5 HashSet</h3><p>new HashSet()底层实现了HashMap</p>
<h3 id="14-6-6-LinkedHashSet"><a href="#14-6-6-LinkedHashSet" class="headerlink" title="14.6.6 LinkedHashSet"></a>14.6.6 LinkedHashSet</h3><p>频繁遍历效率高于HashSet</p>
<h3 id="14-6-7-TreeSet"><a href="#14-6-7-TreeSet" class="headerlink" title="14.6.7 TreeSet"></a>14.6.7 TreeSet</h3><p>添加的数据只能是相同类的</p>
<p>两种排序，自然排序和定制排序</p>
<h4 id="①-特性"><a href="#①-特性" class="headerlink" title="① 特性"></a>① 特性</h4><p>与其他Set不同，判断重复(自然排序中)使用Comparable接口进行判断</p>
<h4 id="②-底层结构"><a href="#②-底层结构" class="headerlink" title="② 底层结构"></a>② 底层结构</h4><p>红黑树存储结构</p>
<h4 id="③-自然排序"><a href="#③-自然排序" class="headerlink" title="③ 自然排序"></a>③ 自然排序</h4><p>实现Comparablechongxie compareTo(Object o)</p>
<h4 id="④-定制排序"><a href="#④-定制排序" class="headerlink" title="④ 定制排序"></a>④ 定制排序</h4><p>new TreeSet(new Comparator)</p>
<h2 id="14-7-Map接口"><a href="#14-7-Map接口" class="headerlink" title="14.7 Map接口"></a>14.7 Map接口</h2><p>双列数据，键值对key-value</p>
<ul>
<li><p>HashMap(主要实现类)：线程不安全，相率高，存储null的key和value</p>
<ul>
<li>LinkedHashMap：可以按照添加的循序实现遍历</li>
</ul>
</li>
<li><p>TreeMap：保证按照添加的key-value进行排序，实现排序遍历，涉及到key的自然排序和定制排序</p>
</li>
<li><p>Hashtable(古老实现类)：线程安全，效率低，不能存储null的key和value</p>
<ul>
<li>Properties：处理配置文件，key和value都是String类型</li>
</ul>
</li>
</ul>
<h3 id="14-7-1-常用方法"><a href="#14-7-1-常用方法" class="headerlink" title="14.7.1 常用方法"></a>14.7.1 常用方法</h3><ul>
<li><p>put(key,value)	putAll(Map) &#x2F;&#x2F;体现的是修改，重复key的value会被覆盖</p>
</li>
<li><p>Object remove(key)</p>
</li>
<li><p>clear()</p>
</li>
<li><p>get(obj)	size()	isEmpty()	equals(obj)</p>
</li>
<li><p>boolean containKey&#x2F;containValue(obj)</p>
</li>
<li><p>元视图的操作方法</p>
</li>
<li><p>Set KeySet()</p>
</li>
<li><p>Collection values()</p>
</li>
<li><p>Set entrySet() &#x2F;&#x2F;得到的都是Entry，通过getKey() getValue()进行获取</p>
</li>
</ul>
<h3 id="14-7-2-底层原理"><a href="#14-7-2-底层原理" class="headerlink" title="14.7.2 底层原理"></a>14.7.2 底层原理</h3><p>jdk7 ：数组+链表</p>
<ul>
<li><p>实例时创建16length的Entry[] table数组</p>
</li>
<li><p>先调hashCode判断，哈希值相同继而调用equals方法进行比较数据</p>
</li>
</ul>
<p>jdk8 ：数组+链表+红黑树</p>
<ul>
<li><p>底层数组是Node[]不是Entry[]</p>
</li>
<li><p>实例化不创建数组</p>
</li>
<li><p>首次调用put()方法，底层创建16length数组</p>
</li>
</ul>
<h3 id="14-7-3-key与value"><a href="#14-7-3-key与value" class="headerlink" title="14.7.3 key与value"></a>14.7.3 key与value</h3><p>key无序，不可重复，Set存储所有的key，获取：Set keySet()</p>
<p>value无序，可重复 ，使用Collection存储所有的value，获取Collection values()</p>
<p>Set entrySet()</p>
<h3 id="14-7-4-LinkedHashMap"><a href="#14-7-4-LinkedHashMap" class="headerlink" title="14.7.4 LinkedHashMap"></a>14.7.4 LinkedHashMap</h3><p>按照添加顺序排序</p>
<h3 id="14-7-5-TreeMap"><a href="#14-7-5-TreeMap" class="headerlink" title="14.7.5 TreeMap"></a>14.7.5 TreeMap</h3><p>key必须向同类型</p>
<p>根据key进行排序：自然排序，定制排序</p>
<h2 id="14-8-Properties"><a href="#14-8-Properties" class="headerlink" title="14.8 Properties"></a>14.8 Properties</h2><p>用来处理配置文件，key和value都是String类型</p>
<ul>
<li><p>直接new Properties()</p>
</li>
<li><p>调用load(InputStream)来加载资源</p>
</li>
<li><p>调getProperty(String key)获取value</p>
</li>
</ul>
<h2 id="14-9-Iterator遍历"><a href="#14-9-Iterator遍历" class="headerlink" title="14.9 Iterator遍历"></a>14.9 Iterator遍历</h2><p>迭代器Iterator接口（设计模式的一种）</p>
<p>使用</p>
<p>hasNext() next() remove()</p>
<p>&#x2F;&#x2F;注：remove()只能在调用next()后执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//next()：指针下移，随后将下移以后的集合位置上的元素返回</span></span><br><span class="line">    iterator.next();</span><br><span class="line">    <span class="comment">/*删除操作(删除集合中的数据)</span></span><br><span class="line"><span class="comment">    Object obj = iterator.next();</span></span><br><span class="line"><span class="comment">    if(&quot;String&quot;.equals(obj))&#123;iterator.remove();&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-10-Foreach遍历"><a href="#14-10-Foreach遍历" class="headerlink" title="14.10 Foreach遍历"></a>14.10 Foreach遍历</h2><p>jdk5.0新增foreach循环，用于遍历集合、数组</p>
<p>内部调用迭代器Iterator实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj ：collection)&#123;</span><br><span class="line">	<span class="comment">//集合类型 局部变量：集合对象</span></span><br><span class="line">    <span class="comment">//数组类型 局部变量：数组对象</span></span><br><span class="line">	sout(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-11-Collections工具类"><a href="#14-11-Collections工具类" class="headerlink" title="14.11 Collections工具类"></a>14.11 Collections工具类</h2><p>操作Set,List,Map的工具类</p>
<ul>
<li><p>reverse(List)	shffle(List)</p>
</li>
<li><p>sort(List)	sort(List,Comparator)</p>
</li>
<li><p>swap(List,int,int) &#x2F;&#x2F;将指定List集合的ij元素进行交换</p>
</li>
<li><p>Object max&#x2F;min(Collection[,Comparator])</p>
</li>
<li><p>int frequency(Collection) &#x2F;&#x2F;返回指定集合中指定元素的出现次数</p>
</li>
<li><p>copy(List dest,List src)</p>
</li>
<li><p>XXX synchronizedXXX(XXX)要求线程安全可以调用此方法，ArrayList和HashMap都线程不安全</p>
</li>
</ul>
<h1 id="十五、泛型Generic"><a href="#十五、泛型Generic" class="headerlink" title="十五、泛型Generic"></a>十五、泛型Generic</h1><p><code>&lt;T&gt;</code>标签</p>
<p>把元素的类型设计为一个参数，这个类型参数叫做泛型</p>
<p>泛型不能是基本数据类型</p>
<p>泛型类型没有被指明某一指定泛型时，默认Object类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDK7类型推断：List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;E&gt;Element</code> (在集合中使用，因为集合中存放的是元素)</li>
<li><code>&lt;T&gt;Type</code>（Java 类），T代表在调用时的指定类型。 </li>
<li><code> &lt;K&gt;Key</code>（键）会进行类型推断</li>
<li><code>&lt;V&gt;Value</code>（值）</li>
</ul>
<p><strong>泛型的指明</strong>：继承泛型时，使用泛型创建对象时</p>
<p><strong>自定义泛型结构</strong>：泛型类、泛型接口、泛型方法、泛型属性</p>
<p>泛型类型不可定义静态方法，静态方法可以被泛型方法定义</p>
<p><strong>泛型方法☆</strong>：</p>
<p>在方法中出现了泛型的结构，泛型的参数与泛型参数没有任何关系，即泛型方法所属的类是不是泛型类都没有关系。</p>
<p>在调用时指明泛型参数的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copy</span><span class="params">(E[] arr)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回类型通过放入的类型决定</span></span><br></pre></td></tr></table></figure>

<p><strong>通配符</strong>：<code>?</code></p>
<ul>
<li><code>&lt;? extends Class&gt;</code></li>
<li><code>&lt;? super Class&gt;</code></li>
</ul>
<h1 id="十六、DAO"><a href="#十六、DAO" class="headerlink" title="十六、DAO"></a>十六、DAO</h1><p>data(base) access object</p>
<p>数据访问对象</p>
<p>数据库连接的类，增删改查</p>
<p>操作数据库的</p>
<h1 id="十七、IO流"><a href="#十七、IO流" class="headerlink" title="十七、IO流"></a>十七、IO流</h1><p>Input Output Stream</p>
<h2 id="17-1-File"><a href="#17-1-File" class="headerlink" title="17.1 File"></a>17.1 File</h2><p>java.io包下</p>
<ul>
<li><p>相对路径：IDEA相对于module</p>
</li>
<li><p>绝对路径：相对于磁盘根目录</p>
</li>
<li><p>分隔符：File.separator</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\\&quot;</span> == <span class="string">&quot;/&quot;</span></span><br><span class="line"><span class="comment">//windows和dos系统用&quot;\&quot;来标识</span></span><br><span class="line"><span class="comment">//unix和url用&quot;/&quot;标识</span></span><br></pre></td></tr></table></figure>

<h3 id="17-1-1-常用方法"><a href="#17-1-1-常用方法" class="headerlink" title="17.1.1 常用方法"></a>17.1.1 常用方法</h3><ul>
<li><p>getAbsolutePath()</p>
</li>
<li><p>getPath()</p>
</li>
<li><p>getName()</p>
</li>
<li><p>getParent()</p>
</li>
<li><p>length()</p>
</li>
<li><p>long lastModified()	&#x2F;&#x2F;获取最后一次修改时间，毫秒值</p>
</li>
<li><p>String[] list()</p>
</li>
<li><p>File[] listFiles()</p>
</li>
<li><p>boolean renameTo(File)文件重命名为指定的文件路径</p>
<ul>
<li>&#x2F;&#x2F;实例：file1.renameTo(file2)，文件1存在，文件2不存在，才可进行转换，有修改路径并重命名的功能</li>
</ul>
</li>
</ul>
<p>判断功能：</p>
<ul>
<li><p>isDirectory()	isFile()	exists()</p>
</li>
<li><p>canRead()	canWrite()	isHidden()</p>
</li>
</ul>
<p>增删功能：</p>
<ul>
<li><p>createNewFile()	mkdir()	mkdirs()</p>
</li>
<li><p>delete() &#x2F;&#x2F;不走回收站</p>
</li>
</ul>
<h2 id="17-2-流"><a href="#17-2-流" class="headerlink" title="17.2 流"></a>17.2 流</h2><p>InputStream OutputStream Reader Writer</p>
<h3 id="17-2-1-关闭流"><a href="#17-2-1-关闭流" class="headerlink" title="17.2.1 关闭流"></a>17.2.1 关闭流</h3><p>写在finally中，先判断流非null，再进行close()</p>
<p>注！！关闭外层流时，内层流也会自动关闭，内层流的手动关闭可以省略</p>
<h2 id="17-3-字节字符流"><a href="#17-3-字节字符流" class="headerlink" title="17.3 字节字符流"></a>17.3 字节字符流</h2><ul>
<li>字符流：文本文件</li>
<li>字节流：非文本文件</li>
</ul>
<h3 id="17-3-1-FileInputStream"><a href="#17-3-1-FileInputStream" class="headerlink" title="17.3.1 FileInputStream"></a>17.3.1 FileInputStream</h3><ul>
<li><p>int read()</p>
</li>
<li><p>int read(byte[])</p>
</li>
</ul>
<h3 id="17-3-2-FileOutputStream"><a href="#17-3-2-FileOutputStream" class="headerlink" title="17.3.2 FileOutputStream"></a>17.3.2 FileOutputStream</h3><ul>
<li><p>write(byte[])</p>
</li>
<li><p>write(byte[],0,len)</p>
</li>
</ul>
<h3 id="17-3-3-FileReader"><a href="#17-3-3-FileReader" class="headerlink" title="17.3.3 FileReader"></a>17.3.3 FileReader</h3><ul>
<li><p>int read() &#x2F;&#x2F;返回字节，读取结束返回-1</p>
</li>
<li><p>while(read() !&#x3D; -1){}</p>
</li>
<li><p>int read(char[]) &#x2F;&#x2F;char型数组，返回每次读入的数据个数，读完返回-1</p>
</li>
</ul>
<h3 id="17-3-4-FileWriter"><a href="#17-3-4-FileWriter" class="headerlink" title="17.3.4 FileWriter"></a>17.3.4 FileWriter</h3><ul>
<li><p>new FileWriter(file,boolean append) &#x2F;&#x2F;append为是否追加数据</p>
</li>
<li><p>new String(char[],0,len)</p>
</li>
<li><p>write(str)</p>
</li>
</ul>
<p>源文件不存在则新建文件</p>
<h2 id="17-4-字符字节缓冲流"><a href="#17-4-字符字节缓冲流" class="headerlink" title="17.4 字符字节缓冲流"></a>17.4 字符字节缓冲流</h2><p>开发时常使用字符字节缓冲流处理，内部1024*8长度字节数组接收数据，提高流的读取和写出速度</p>
<p>先造节点流FileXXX再造缓冲流</p>
<ul>
<li><p>BufferedInputStream</p>
</li>
<li><p>BufferedOutputStream</p>
<ul>
<li>flush() &#x2F;&#x2F;刷新缓冲区</li>
</ul>
</li>
<li><p>BufferedReader</p>
<ul>
<li>String readLine() &#x2F;&#x2F;读完返回null，不接收换行符</li>
</ul>
</li>
<li><p>BufferedWriter</p>
<ul>
<li><p>flush()</p>
</li>
<li><p>newLine()</p>
</li>
</ul>
</li>
</ul>
<h2 id="17-5-转换流"><a href="#17-5-转换流" class="headerlink" title="17.5 转换流"></a>17.5 转换流</h2><p>字节流和字符流之间的转换</p>
<ul>
<li>字节&#x3D;&#x3D;&gt;字符</li>
<li>编码&#x3D;&#x3D;&gt;解码</li>
</ul>
<p>第二个参数不写为系统默认字符集，一般写utf8</p>
<h3 id="17-5-1-InputStreamReader解码"><a href="#17-5-1-InputStreamReader解码" class="headerlink" title="17.5.1 InputStreamReader解码"></a>17.5.1 InputStreamReader解码</h3><p>存入时什么字符集写什么字符集</p>
<h3 id="17-5-2-OutputStreamWriter编码"><a href="#17-5-2-OutputStreamWriter编码" class="headerlink" title="17.5.2 OutputStreamWriter编码"></a>17.5.2 OutputStreamWriter编码</h3><p>想以什么字符集输出就写什么字符集</p>
<h2 id="17-6-标准输入输出流"><a href="#17-6-标准输入输出流" class="headerlink" title="17.6 标准输入输出流"></a>17.6 标准输入输出流</h2><p>System.in	System.out	&#x2F;&#x2F;字节流</p>
<p>默认控制台输入输出</p>
<p>System.setIn(InputStream in)</p>
<p>System.setOut(PrintStream out)</p>
<p>重新指定输入输出的流</p>
<h2 id="17-7-打印流"><a href="#17-7-打印流" class="headerlink" title="17.7 打印流"></a>17.7 打印流</h2><p>PrintStream	PrintWriter</p>
<p>基本数据类型格式转化为字符串输出</p>
<p>print()</p>
<p>println()</p>
<p>提供了一系列重载的方法</p>
<h2 id="17-8-数据流"><a href="#17-8-数据流" class="headerlink" title="17.8 数据流"></a>17.8 数据流</h2><p>将数据持久化到文件中，读取或写出基本数据类型的变量或字符串</p>
<h3 id="17-8-1-DataInputStream"><a href="#17-8-1-DataInputStream" class="headerlink" title="17.8.1 DataInputStream"></a>17.8.1 DataInputStream</h3><h3 id="17-8-2-DataOutputStream"><a href="#17-8-2-DataOutputStream" class="headerlink" title="17.8.2 DataOutputStream"></a>17.8.2 DataOutputStream</h3><p>writeUTF(String str)</p>
<p>writeInt(int)</p>
<p>writeBoolean(true)</p>
<p>flush()</p>
<h2 id="17-9-对象流"><a href="#17-9-对象流" class="headerlink" title="17.9 对象流"></a>17.9 对象流</h2><p>存储和读取基本数据类型数据或对象，一个文件中基本都是一个类型</p>
<h3 id="17-9-1-实现Serializable接口"><a href="#17-9-1-实现Serializable接口" class="headerlink" title="17.9.1 实现Serializable接口"></a>17.9.1 实现Serializable接口</h3><h3 id="17-9-2-类体声明序列化版本"><a href="#17-9-2-类体声明序列化版本" class="headerlink" title="17.9.2 类体声明序列化版本"></a>17.9.2 类体声明序列化版本</h3><p>不显示定义会自动生成UID，但若是对类修改，UID发生变化可能无法进行反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1837592785982379257L</span>;</span><br></pre></td></tr></table></figure>

<p>对象序列化机制：自行百度理解</p>
<h3 id="17-9-3-特别"><a href="#17-9-3-特别" class="headerlink" title="17.9.3 特别"></a>17.9.3 特别</h3><p>不能序列化static和transient修饰的成员变量</p>
<h3 id="17-9-4-ObjectOutputStream"><a href="#17-9-4-ObjectOutputStream" class="headerlink" title="17.9.4 ObjectOutputStream"></a>17.9.4 ObjectOutputStream</h3><p>序列化，最好为.dat格式</p>
<p>写出到文件中</p>
<h3 id="17-9-5-ObjectInputStream"><a href="#17-9-5-ObjectInputStream" class="headerlink" title="17.9.5 ObjectInputStream"></a>17.9.5 ObjectInputStream</h3><p>反序列化</p>
<p>读取到内存中</p>
<h2 id="17-10-RandomAccessFile"><a href="#17-10-RandomAccessFile" class="headerlink" title="17.10 RandomAccessFile"></a>17.10 RandomAccessFile</h2><p>任意(随机)存取文件流</p>
<p>直接继承Object类，实现了DataInput和DataOutput接口</p>
<p>即可以作为输入，也可以作为输出</p>
<p>new RandomAccessFile(FIle,mode)</p>
<p>默认write从头开始逐个覆盖</p>
<p>可以深入文件内部修改</p>
<h3 id="17-10-7-mode"><a href="#17-10-7-mode" class="headerlink" title="17.10.7 mode"></a>17.10.7 mode</h3><ul>
<li>r：只读</li>
<li>rw：读写</li>
<li>rwd：读写，且同步内容的更新</li>
<li>rws：读写，且同步文件内容和元数据的更新</li>
</ul>
<h3 id="17-10-8-常用方法"><a href="#17-10-8-常用方法" class="headerlink" title="17.10.8 常用方法"></a>17.10.8 常用方法</h3><p>seek(int position)	&#x2F;&#x2F;指向某个位置</p>
<p>&#x2F;&#x2F;可以通过file.length()获取长度，通过seek进行文件末尾追加操作</p>
<h2 id="17-11-ByteArrayOutputStream"><a href="#17-11-ByteArrayOutputStream" class="headerlink" title="17.11 ByteArrayOutputStream"></a>17.11 ByteArrayOutputStream</h2><p>创建此对象构造器为空，调用write方法写出的数据存在对象中，当对象内存被沾满时，会自动扩容</p>
<h2 id="17-12-NIO-2"><a href="#17-12-NIO-2" class="headerlink" title="17.12 NIO.2"></a>17.12 NIO.2</h2><p>NIO出自JDK1.4更加高效的方式进行文件读写，但不太行，于是有了NIO.2</p>
<ul>
<li>Path、Paths、Files核心API</li>
<li>Path path &#x3D; Paths.get(“文件路径”); &#x2F;&#x2F;可获取文件</li>
</ul>
<h3 id="17-12-1-Path"><a href="#17-12-1-Path" class="headerlink" title="17.12.1 Path"></a>17.12.1 Path</h3><p>可替代File类</p>
<h3 id="17-12-2-Paths"><a href="#17-12-2-Paths" class="headerlink" title="17.12.2 Paths"></a>17.12.2 Paths</h3><p>静态方法get(String first,String … more) &#x2F;&#x2F;可选多个字符串组成文档路径，返回一个路径</p>
<h2 id="17-13-apach-commons-io"><a href="#17-13-apach-commons-io" class="headerlink" title="17.13 apach-commons-io"></a>17.13 apach-commons-io</h2><p>第三方jar实现数据读写</p>
<h3 id="17-13-1-FileUtils"><a href="#17-13-1-FileUtils" class="headerlink" title="17.13.1 FileUtils"></a>17.13.1 FileUtils</h3><p>copyFile()</p>
<p>…</p>
<h1 id="十八、网络编程Socket"><a href="#十八、网络编程Socket" class="headerlink" title="十八、网络编程Socket"></a>十八、网络编程Socket</h1><p>IP：定位唯一的主机</p>
<p>端口号：定位软件通信，用来区分主机上的软件</p>
<p>网络通信协议</p>
<p>OSI TCP&#x2F;IP</p>
<h2 id="18-1-IP分为IPv4和IPv6"><a href="#18-1-IP分为IPv4和IPv6" class="headerlink" title="18.1 IP分为IPv4和IPv6"></a>18.1 IP分为IPv4和IPv6</h2><ul>
<li><p>IPV4：4字节组成，4个0~255</p>
</li>
<li><p>IPV6：128位，16个字节，分成8个无符号整数，每个整数使用4个16进制标识，例如：	3ffe：3201：1401：…</p>
</li>
<li><p>分类：公网(万维网，公有地址)和局域网(私有地址)</p>
</li>
<li><p>私有地址：192.168.0.0-192.168.255.255</p>
</li>
<li><p>域名：<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></p>
</li>
<li><p>DNS：解析域名为IPV4&#x2F;IPV6地址</p>
</li>
</ul>
<h2 id="18-2-端口号"><a href="#18-2-端口号" class="headerlink" title="18.2 端口号"></a>18.2 端口号</h2><ul>
<li>公认端口：0~1023，HTTP：80,FTP：21,Telnet：23</li>
<li>注册端口：1024~49151，Tomcat：8080,MySQL：3306,Oracle：1521</li>
<li>动态&#x2F;私有端口：49152~65535</li>
</ul>
<h2 id="18-3-网络通信协议"><a href="#18-3-网络通信协议" class="headerlink" title="18.3 网络通信协议"></a>18.3 网络通信协议</h2><h3 id="18-3-1-TCP"><a href="#18-3-1-TCP" class="headerlink" title="18.3.1 TCP"></a>18.3.1 TCP</h3><ul>
<li>可靠</li>
<li>先建立TCP链接，形成传输数据通道</li>
<li>三次握手</li>
<li>连接时可发送大量数据</li>
<li>传输完毕释放连接，效率低</li>
</ul>
<h3 id="18-3-2-UDP"><a href="#18-3-2-UDP" class="headerlink" title="18.3.2 UDP"></a>18.3.2 UDP</h3><ul>
<li>不可靠</li>
<li>不需要建立连接</li>
<li>数据报发送，大小限制64K</li>
<li>可以广播发送</li>
<li>发送数据结束无需释放资源，开销小，速度快</li>
</ul>
<h2 id="18-4-InetAddress"><a href="#18-4-InetAddress" class="headerlink" title="18.4 InetAddress"></a>18.4 InetAddress</h2><ul>
<li>唯一标识Internet上的计算机(通信实体)</li>
<li>本地回环地址127.0.0.1</li>
<li>主机名：localhost</li>
</ul>
<h3 id="18-4-1-常用方法"><a href="#18-4-1-常用方法" class="headerlink" title="18.4.1 常用方法"></a>18.4.1 常用方法</h3><ul>
<li>InetAddress.getByName(“address”) &#x2F;&#x2F;实例化，可写域名或IP</li>
<li>InetAddress.getLocalHost()</li>
</ul>
<p>&#x2F;&#x2F;获取的域名会自动返回网络上的实际地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">            System.out.println(inet1);</span><br><span class="line"><span class="comment">//www.baidu.com/39.156.66.18            </span></span><br></pre></td></tr></table></figure>

<h2 id="18-5-Socket：TCP"><a href="#18-5-Socket：TCP" class="headerlink" title="18.5 Socket：TCP"></a>18.5 Socket：TCP</h2><p>端口号和IP地址的组合得出一个网络套接字</p>
<p>先有服务器ServerSocket后有客户端Socket</p>
<h3 id="18-5-1-常用方法"><a href="#18-5-1-常用方法" class="headerlink" title="18.5.1 常用方法"></a>18.5.1 常用方法</h3><ul>
<li>关闭socket传输：shutdownOut[In]put()</li>
<li>客户端：new Socket(InetAddress,port)</li>
<li>OutputStream getOutputStream(); &#x2F;&#x2F;调os的write输出</li>
<li>服务器：new ServerSocket(port)</li>
<li>accept() &#x2F;&#x2F;接收Socket</li>
<li>InputStream getInputStream() &#x2F;&#x2F;获取客户端传来的数据</li>
</ul>
<p>&#x2F;&#x2F;建议接收数据存入ByteArrayOutputStream，使用baos.toString()进行输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="18-6-TCP通信"><a href="#18-6-TCP通信" class="headerlink" title="18.6 TCP通信"></a>18.6 TCP通信</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------服务器启动------------&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ServerReceiveThread</span>(accept)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务器线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReceiveThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReceiveThread</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">            String message;</span><br><span class="line">            <span class="keyword">while</span> ((message = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(socket.getInetAddress().getHostName() + <span class="string">&quot;-&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;：&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getInetAddress().getHostName() + <span class="string">&quot;-&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;：&quot;</span> + <span class="string">&quot;下线了&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet, <span class="number">8888</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;发送：&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (sc.hasNextLine()) &#123;</span><br><span class="line">                    ps.println(sc.nextLine());</span><br><span class="line">                    ps.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-7-DatagramSocket：UDP"><a href="#18-7-DatagramSocket：UDP" class="headerlink" title="18.7 DatagramSocket：UDP"></a>18.7 DatagramSocket：UDP</h2><p>客户端</p>
<p>new DatagramSocket()</p>
<p>new DatagramPacket(data,0,data.length,InetAddress)发送的数据包 &#x2F;&#x2F;data为byte[]</p>
<p>send(packet)发送</p>
<p>close()关闭socket连接</p>
<p>服务器</p>
<p>new DatagramSocket(port)</p>
<p>new DatagramPacket(data,0,data.length)接受数据</p>
<p>receive(packet)</p>
<p>使用packet.getData()获取数据</p>
<h2 id="18-8-URL"><a href="#18-8-URL" class="headerlink" title="18.8 URL"></a>18.8 URL</h2><ul>
<li>统一资源定位符Uniform Resource Locator</li>
<li>对应互联网上某一资源地址</li>
<li>http：&#x2F;&#x2F;loaclhost：8080&#x2F;bamboo&#x2F;new.jpg</li>
<li>协议	主机名		端口号	资源地址</li>
</ul>
<h3 id="18-8-1-常用方法"><a href="#18-8-1-常用方法" class="headerlink" title="18.8.1 常用方法"></a>18.8.1 常用方法</h3><p><code>HttpURLConnection openConnection()</code> &#x2F;&#x2F;用于连接,调用connect()获取连接，使用getInputStream()读入输入流，使用disconnect()关闭连接</p>
<ul>
<li>getProtocol()获取协议</li>
<li>getHost()获取主机名</li>
<li>getPort()获取端口号</li>
<li>getPath()获取文件路径</li>
<li>getFile()获取文件名</li>
<li>getQuery()获取查询名</li>
</ul>
<h1 id="十九、反射机制"><a href="#十九、反射机制" class="headerlink" title="十九、反射机制"></a>十九、反射机制</h1><p>Reflection（反射），被视为<strong>动态语言</strong>的关键</p>
<p>获取类的内部信息，直接操作任意对象的内部属性和方法</p>
<p>动态语言：运行时代码根据某些条件改变自身条件</p>
<ul>
<li>java.lang.Class</li>
<li>java.lang.reflect.Method</li>
<li>java.lang.reflect.Field</li>
<li>java.lang.reflect.Constructor</li>
<li>……</li>
</ul>
<p><strong>反射前</strong>：不可以通过new的对象进行调用内部private成员或方法</p>
<p><strong>反射后</strong>：可调用private属性或方法</p>
<h2 id="19-1-常用方法"><a href="#19-1-常用方法" class="headerlink" title="19.1 常用方法"></a>19.1 常用方法</h2><ul>
<li>Class.class用于制造Class类</li>
<li>class.getConstructor(param.class…) 进行构造器的创建</li>
<li>constructor.newInstance(param…)进行实例化对象</li>
<li>class.getDeclaredField(String fieldName)	fieldName.set(class实例,param)</li>
</ul>
<p>&#x2F;&#x2F;反射出属性修改</p>
<ul>
<li>class.getDeclaredMethod(String methodName,paramType.class)	methodName.invoke(class对象)</li>
</ul>
<p>&#x2F;&#x2F;反射出方法进行调用，如果有返回值，强转返回值类型并接收</p>
<ul>
<li>setAccessible(boolean) &#x2F;&#x2F;破怀封住性，true时可以调用private修饰的结构</li>
</ul>
<h2 id="19-2-使用条件"><a href="#19-2-使用条件" class="headerlink" title="19.2 使用条件"></a>19.2 使用条件</h2><p>反射特性：动态性</p>
<p>不确定具体对象时使用</p>
<h2 id="19-3-Class理解"><a href="#19-3-Class理解" class="headerlink" title="19.3 Class理解"></a>19.3 Class理解</h2><p>javac.exe编译后生成一个或多个字节码文件.class</p>
<p>类的加载：使用java.exe对字节码文件进行解释运行，将字节码文件加载到内存中。加载到内存中的类，称为运行时类，作为Class的一个实例</p>
<h2 id="19-4-获取Class实例"><a href="#19-4-获取Class实例" class="headerlink" title="19.4 获取Class实例"></a>19.4 获取Class实例</h2><p>方式一：调运行时类的属性.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure>

<p>方式二：调运行时类的对象，调用getClass()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> p1.getClass();</span><br></pre></td></tr></table></figure>

<p>方式三：调Class静态方法forName(String classpath) &#x2F;&#x2F;比较常用，体现反射动态性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bamboo.java.Person&quot;</span>);<span class="comment">//抛出ClassNotFound异常</span></span><br></pre></td></tr></table></figure>

<p>方式四：使用类加载器ClassLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> 类.class.getClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> cl.loadClass(<span class="string">&quot;com.bamboo.java.Person&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="19-5-获取Class属性"><a href="#19-5-获取Class属性" class="headerlink" title="19.5 获取Class属性"></a>19.5 获取Class属性</h2><h3 id="19-5-1-使用Declared修饰的方法"><a href="#19-5-1-使用Declared修饰的方法" class="headerlink" title="19.5.1 使用Declared修饰的方法"></a>19.5.1 使用Declared修饰的方法</h3><p>&#x2F;&#x2F;getFields()	getDeclaredFields()区别：后者不考虑权限，前者考虑权限，如private则不可被调用</p>
<h3 id="19-5-2-Field：属性"><a href="#19-5-2-Field：属性" class="headerlink" title="19.5.2 Field：属性"></a>19.5.2 Field：属性</h3><p>Modifier：权限修饰符，获取时返回Int，default：0 public：1 private：2</p>
<p>&#x2F;&#x2F;可通过Modifier.toString(int modifier)获取对应数值的权限字符串名</p>
<ul>
<li>Type：数据类型，返回Class类型，调getName()返回数据类型名</li>
<li>Name：属性名，返回String</li>
</ul>
<h3 id="19-5-3-Method：方法名"><a href="#19-5-3-Method：方法名" class="headerlink" title="19.5.3 Method：方法名"></a>19.5.3 Method：方法名</h3><ul>
<li>Annotation：注解，先获取属性或方法，再获取注解</li>
<li>ReturnType：返回值类型</li>
<li>ParamaterTypes：获取参数类型</li>
<li>ExceptionTypes：获取异常</li>
</ul>
<h3 id="19-5-4-Constructor：构造器"><a href="#19-5-4-Constructor：构造器" class="headerlink" title="19.5.4 Constructor：构造器"></a>19.5.4 Constructor：构造器</h3><h3 id="19-5-5-Superclass：运行时父类"><a href="#19-5-5-Superclass：运行时父类" class="headerlink" title="19.5.5 Superclass：运行时父类"></a>19.5.5 Superclass：运行时父类</h3><p>GenericSuperclass：带泛型的父类</p>
<h3 id="19-5-6-Interface：接口"><a href="#19-5-6-Interface：接口" class="headerlink" title="19.5.6 Interface：接口"></a>19.5.6 Interface：接口</h3><h3 id="19-5-7-Package：包"><a href="#19-5-7-Package：包" class="headerlink" title="19.5.7 Package：包"></a>19.5.7 Package：包</h3><h2 id="19-6-设置"><a href="#19-6-设置" class="headerlink" title="19.6 设置"></a>19.6 设置</h2><p>使用Declared修饰的get方法获取属性。。。等(可获取被private的属性。。。)</p>
<ul>
<li>setAccessible(true)保证当前属性可访问</li>
<li>设置属性set(实例,值)</li>
<li>获取属性get(实例)</li>
</ul>
<p>方法获取：参数1为方法名，参数2为形参列表…</p>
<p>调用方法invoke(实例,参数…)，返回值为对应类中的返回值类型，如是static方法，使用Class.class作为实例参数</p>
<p>获取构造器，参数写类.class，调newInstance()创建对象</p>
<h2 id="19-7-创建运行时类的对象"><a href="#19-7-创建运行时类的对象" class="headerlink" title="19.7 创建运行时类的对象"></a>19.7 创建运行时类的对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"><span class="comment">//前提：具有空参构造器，权限不是private，通常设置为public</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> clazz.newInstance();<span class="comment">//内部调用了Person类的空参构造器</span></span><br><span class="line"><span class="comment">//习惯用Class建立对象，比较通用，使用获取的构造器造对象可能导致不通用(其中参数不同)</span></span><br></pre></td></tr></table></figure>



<h2 id="19-8-可获取Class实例的结构"><a href="#19-8-可获取Class实例的结构" class="headerlink" title="19.8 可获取Class实例的结构"></a>19.8 可获取Class实例的结构</h2><p>外部类，成员(成员内部类，静态内部类),局部内部类，匿名内部类</p>
<p>interface []数组 enum annotation 基本数据类型 void Class</p>
<p>元素类型和元素维度相同，则被认为同一Class实例</p>
<h2 id="19-9-ClassLoader读配置文件"><a href="#19-9-ClassLoader读配置文件" class="headerlink" title="19.9 ClassLoader读配置文件"></a>19.9 ClassLoader读配置文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> 类.class.getClassLoader().getResourceAsStream(<span class="string">&quot;xxx.properties&quot;</span>);</span><br><span class="line"><span class="comment">//获取类路径为classpath，根目录下</span></span><br><span class="line">pros.load(is);</span><br><span class="line"><span class="type">String</span> <span class="variable">xxx</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="19-10-反射应用：动态代理"><a href="#19-10-反射应用：动态代理" class="headerlink" title="19.10 反射应用：动态代理"></a>19.10 反射应用：动态代理</h2><p>????????????????????????????????????????????????</p>
<h1 id="二十、JDK8新特性"><a href="#二十、JDK8新特性" class="headerlink" title="二十、JDK8新特性"></a>二十、JDK8新特性</h1><p>14年发布，滞后期，出来后经过时间的检验才被使用</p>
<h2 id="20-1-Lambda表达式"><a href="#20-1-Lambda表达式" class="headerlink" title="20.1 Lambda表达式"></a>20.1 Lambda表达式</h2><p>简化写法：<code>-&gt; ：Lambda操作符 或 箭头操作符</code></p>
<ul>
<li>左：参数列表</li>
<li>右：Lambda体</li>
<li>格式：(e1,e2)-&gt;{sout…};</li>
<li>无参可只写()</li>
<li>只有一个参数可写为：e1-&gt;{}</li>
<li>单个语句不需要书写{}</li>
<li>直接返回的语句不需要写{}，也不能写return</li>
</ul>
<h2 id="20-2-函数式接口"><a href="#20-2-函数式接口" class="headerlink" title="20.2 函数式接口"></a>20.2 函数式接口</h2><p>@FunctionalInterface：用于实现Lambda表达式</p>
<p>只有一个抽象方法的接口</p>
<h3 id="20-2-1-内置四大核心函数式接口"><a href="#20-2-1-内置四大核心函数式接口" class="headerlink" title="20.2.1 内置四大核心函数式接口"></a>20.2.1 内置四大核心函数式接口</h3><ul>
<li><code>Consumer&lt;T&gt; ：void accept(T t) </code>&#x2F;&#x2F;消费型接口</li>
<li><code>Supplier&lt;T&gt; ：T get() </code>&#x2F;&#x2F;供给型接口</li>
<li><code>Function&lt;T,R&gt; ：R apply(T t)</code> &#x2F;&#x2F;函数型接口</li>
<li><code>Predicate&lt;T&gt; ：boolean test(T t) </code>&#x2F;&#x2F;断言型接口</li>
</ul>
<h2 id="20-3-方法引用"><a href="#20-3-方法引用" class="headerlink" title="20.3 方法引用"></a>20.3 方法引用</h2><p><code>&quot;::&quot;  ：MethodReferences</code></p>
<p>使用：当要传递给Lambda体的操作，已经有实现的方法，就可以使用方法引用，本质上就是Lambda表达式</p>
<ul>
<li>方式一：对象：：实例方法</li>
<li>方式二：类：：静态方法</li>
<li>方式三：类：：实例方法</li>
<li>构造器引用</li>
<li>方法引用</li>
</ul>
<h2 id="20-4-Stream-API"><a href="#20-4-Stream-API" class="headerlink" title="20.4 Stream API"></a>20.4 Stream API</h2><p>对集合进行操作</p>
<h3 id="20-4-1-注"><a href="#20-4-1-注" class="headerlink" title="20.4.1 注"></a>20.4.1 注</h3><p>不会改变源数据，会返回一个持有结果的Stream流</p>
<p>延迟操作，执行终止操作前都不会执行</p>
<p>每次终止后需要新建Stream流</p>
<h3 id="20-4-2-使用步骤"><a href="#20-4-2-使用步骤" class="headerlink" title="20.4.2 使用步骤"></a>20.4.2 使用步骤</h3><p>1.创建Stream</p>
<p>2.中间操作</p>
<p>3.终止操作(终端操作)</p>
<h3 id="20-4-3-创建方式"><a href="#20-4-3-创建方式" class="headerlink" title="20.4.3 创建方式"></a>20.4.3 创建方式</h3><p>一、集合创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序流</span></span><br><span class="line"><span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> list.stream();</span><br><span class="line"><span class="comment">//并行流，像线程</span></span><br><span class="line"><span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> list.parallelStream();</span><br></pre></td></tr></table></figure>

<p>二、数组创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过Arrays类的静态方法创建</span></span><br><span class="line"><span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr[]);</span><br><span class="line"><span class="comment">//IntStream stream = Arrays.stream(arr[]);当数组是int时返回指定类型流</span></span><br></pre></td></tr></table></figure>

<p>三、Stream的of()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> Stream.of(T... value);</span><br></pre></td></tr></table></figure>

<p>四、创建无限流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed,<span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">具有限制limit和终止操作forEach结束</span></span><br><span class="line"><span class="comment">Stream.iterate(0,t-&gt;t+2).limit(10).forEach(System.out：：print);</span></span><br><span class="line"><span class="comment">Console： 0 2 4 6 8 10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Stream.generate(Math：：random).limit(10).forEach(System.out：：print);</span></span><br><span class="line"><span class="comment">Console： 0 2 4 6 8 10 随机数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="20-4-4-中间操作"><a href="#20-4-4-中间操作" class="headerlink" title="20.4.4 中间操作"></a>20.4.4 中间操作</h3><h4 id="①-筛选与切片"><a href="#①-筛选与切片" class="headerlink" title="① 筛选与切片"></a>① 筛选与切片</h4><ul>
<li>filter(Predicate p) 接收Lambda 排除某些元素</li>
<li>distinct() 筛选去重</li>
<li>limit(n) 截断，不超过给定数量</li>
<li>skip(n) 跳过元素返回被跳过的n个元素的流</li>
</ul>
<h4 id="②-映射"><a href="#②-映射" class="headerlink" title="② 映射"></a>② 映射</h4><ul>
<li>map(Function f) 接收一个函数作为参数，应用到每一个元素上，将其映射成一个新的元素，返回新的类型</li>
<li>flagMap(Function f) 将流中的每个值都换成另一个流，将所有流连成一个流，解锁Stream嵌套 Stream&lt;Stream<String>&gt;</li>
<li>map类似add，flagMap类似addAll</li>
</ul>
<h4 id="③-排序"><a href="#③-排序" class="headerlink" title="③ 排序"></a>③ 排序</h4><ul>
<li>sorted() sorted(Comparator com)</li>
<li>自然排序(implements Comparable) 和 定制排序</li>
</ul>
<h3 id="20-4-5-终止操作"><a href="#20-4-5-终止操作" class="headerlink" title="20.4.5 终止操作"></a>20.4.5 终止操作</h3><h4 id="①-匹配与查找"><a href="#①-匹配与查找" class="headerlink" title="① 匹配与查找"></a>① 匹配与查找</h4><ul>
<li>boolean allMatch(Predicate p)</li>
<li>boolean anyMatch(Predicate p)</li>
<li>boolean noneMatch(Predicate p)</li>
<li>findFirst()</li>
<li>findAny()</li>
<li>Long count()</li>
<li>Object max(Comparator c)</li>
<li>Object min(Comparator c)</li>
<li>forEach(Consumer c) &#x2F;&#x2F;Stream是内部迭代，Collection做迭代是外部迭代</li>
</ul>
<h4 id="②-归约"><a href="#②-归约" class="headerlink" title="② 归约"></a>② 归约</h4><ul>
<li>reduce(T iden,BinaryOperator b) 流中元素反复结合，得到一个值，返回T，identity是初始值</li>
<li>reduce(BinaryOperator b) 流中元素反复结合，得到一个值，返回Optional<T></li>
</ul>
<h4 id="③-收集"><a href="#③-收集" class="headerlink" title="③ 收集"></a>③ 收集</h4><ul>
<li><p>collect(Collector c) </p>
</li>
<li><p>需要传入参数：Collectors.{toList() toSet toCollection()}</p>
</li>
<li><p>……</p>
</li>
</ul>
<h2 id="20-5-Optional"><a href="#20-5-Optional" class="headerlink" title="20.5 Optional"></a>20.5 Optional</h2><p><strong>处理臭名昭著的空指针异常</strong></p>
<p><code>Optional&lt;T&gt;</code>是一个容器类，保存类型T的值</p>
<h3 id="20-5-1-创建Optional类对象"><a href="#20-5-1-创建Optional类对象" class="headerlink" title="20.5.1 创建Optional类对象"></a>20.5.1 创建Optional类对象</h3><p>Optional.of(T t) 创建一个Optional实例，t必须非空</p>
<p>Optional.empty()创建空的Optional实例</p>
<p>Optional.ofNullable(T t)创建一个t可以是null的实例</p>
<h3 id="20-5-2-判断Optional容器"><a href="#20-5-2-判断Optional容器" class="headerlink" title="20.5.2 判断Optional容器"></a>20.5.2 判断Optional容器</h3><p>boolean isPersent() 判断是否包含对象</p>
<p>void ifPresent(Consumer&lt;? super T&gt; consumer) 如果有值，就执行接口的实现代码，并且该值会作为参数传给它。</p>
<h3 id="20-5-3-获取Optional容器的对象"><a href="#20-5-3-获取Optional容器的对象" class="headerlink" title="20.5.3 获取Optional容器的对象"></a>20.5.3 获取Optional容器的对象</h3><ul>
<li>T get() 调用对象包含值，没有则抛异常</li>
<li>T orElse(T other) 没值则返回指定other对象</li>
<li>……</li>
</ul>
<h3 id="20-5-4-优化代码-NullPointerException"><a href="#20-5-4-优化代码-NullPointerException" class="headerlink" title="20.5.4 优化代码,NullPointerException"></a>20.5.4 优化代码,NullPointerException</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">(Class c)</span>&#123;</span><br><span class="line">    Optional&lt;Class&gt; o = Optional.ofNullable(c);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">returnC</span> <span class="operator">=</span> o.orElse(<span class="keyword">new</span> <span class="title class_">Class</span>(<span class="string">&quot;param&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> returnC.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二十一、JDK9"><a href="#二十一、JDK9" class="headerlink" title="二十一、JDK9"></a>二十一、JDK9</h1><p>此版本开始发布新版本周期为6个月</p>
<p>三年为周期发布长期支持版本LST(long term support)</p>
<h1 id="二十二、小Tips"><a href="#二十二、小Tips" class="headerlink" title="二十二、小Tips"></a>二十二、小Tips</h1><p>1.使用Scanner时，先进行hasNextLine()判断，再进行nextLine()接收，杜绝报错</p>
<p>2.引用类型数组中：先判断是否&#x3D;&#x3D;null后使用”||”进行.length&#x3D;&#x3D;0判断，杜绝空指针异常且判断因哟红数组长度</p>
<p>&#x2F;&#x2F;(quoteArr &#x3D;&#x3D; null) || (quoteArr.length &#x3D;&#x3D; 0)</p>
<h1 id="二十三、IDEA"><a href="#二十三、IDEA" class="headerlink" title="二十三、IDEA"></a>二十三、IDEA</h1><p>JetBrains(捷克)公司开发</p>
<h2 id="23-1-基本设置"><a href="#23-1-基本设置" class="headerlink" title="23.1 基本设置"></a>23.1 基本设置</h2><ol>
<li>取消更新</li>
<li>设置字体13、14</li>
<li>设置字符编码</li>
<li>忽略大小写提示</li>
<li>设置模板template</li>
<li>设置maven</li>
<li>VM添加-Dfile.encoding&#x3D;UTF-8    &#x2F;&#x2F;可解决TomcatCatalinaLog中文乱码</li>
</ol>
<h3 id="23-1-idea-properties"><a href="#23-1-idea-properties" class="headerlink" title="23.1 idea.properties"></a>23.1 idea.properties</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">idea.config.path</span>=<span class="string">$&#123;user.home&#125;/.IntelliJIdea/config</span></span><br><span class="line"></span><br><span class="line"><span class="attr">idea.config.path</span>=<span class="string">D：\Develop\JetBrains\IntelliJ IDEA/config</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Uncomment</span> <span class="string">this option if you want to customize a path to the caches directory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">idea.system.path</span>=<span class="string">$&#123;user.home&#125;/.IntelliJIdea/system</span></span><br><span class="line"></span><br><span class="line"><span class="attr">idea.config.path</span>=<span class="string">D：\Develop\JetBrains\IntelliJ IDEA/system</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Uncomment</span> <span class="string">this option if you want to customize a path to the user-installed plugins directory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">idea.plugins.path</span>=<span class="string">$&#123;idea.config.path&#125;/plugins</span></span><br><span class="line"></span><br><span class="line"><span class="attr">idea.plugins.path</span>=<span class="string">D：\Develop\JetBrains\IntelliJ IDEA/plugins</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Uncomment</span> <span class="string">this option if you want to customize a path to the logs directory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">idea.log.path</span>=<span class="string">$&#123;idea.system.path&#125;/log</span></span><br><span class="line"></span><br><span class="line"><span class="attr">idea.log.path</span>=<span class="string">D：\Develop\JetBrains\IntelliJ IDEA/log</span></span><br></pre></td></tr></table></figure>



<h2 id="23-2-plugins"><a href="#23-2-plugins" class="headerlink" title="23.2 plugins"></a>23.2 plugins</h2><h3 id="Auto-filling-Java-call-arguments"><a href="#Auto-filling-Java-call-arguments" class="headerlink" title="Auto filling Java call arguments"></a>Auto filling Java call arguments</h3><p>安装完该插件以后，调用一个函数，使用 Alt+Enter 组合键，调出 “Auto fill call parameters” 自动使用该函数定义的参数名填充</p>
<h3 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h3><p>以安装该插件，安装后 IDEA 中打开 pom.xml 文件时，就会多出一个 “Dependency Analyzer” 选项卡</p>
<h3 id="MyBatisCodeHelperPro"><a href="#MyBatisCodeHelperPro" class="headerlink" title="MyBatisCodeHelperPro"></a>MyBatisCodeHelperPro</h3><p>mybatis代码帮助插件。最好的Mybatis代码提示，完整支持Mybatis动态sql代码提示，代码检测，写sql几乎所有地方都有代码提示</p>
<h3 id="Free-MyBatis-plugin"><a href="#Free-MyBatis-plugin" class="headerlink" title="Free MyBatis plugin"></a>Free MyBatis plugin</h3><p>mybatis 增强插件。free-idea-mybatis是一款增强idea对mybatis支持的插件。快速从代码跳转到mapper及从mapper返回代码。</p>
<h3 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h3><p>阿里巴巴代码规范插件。</p>
<h3 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h3><p>拖动浏览代码更加方便，还有放大镜功能</p>
<h3 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h3><p>它可以实现配对括号相同颜色，并且实现选中区域代码高亮的功能。对增强写代码的有趣性和排错等都有一些帮助。</p>
<h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>设置微软后Ctrl+Shift+Y获得翻译，可设置原始格式翻译</p>
<h3 id="One-Dark-theme"><a href="#One-Dark-theme" class="headerlink" title="One Dark theme"></a>One Dark theme</h3><p>黑暗主题</p>
<h3 id="Atom-Material-Icons"><a href="#Atom-Material-Icons" class="headerlink" title="Atom_Material_Icons"></a>Atom_Material_Icons</h3><p>图标更替</p>
<h2 id="23-3-快捷键"><a href="#23-3-快捷键" class="headerlink" title="23.3 快捷键"></a>23.3 快捷键</h2><h3 id="23-3-1-基本快捷键"><a href="#23-3-1-基本快捷键" class="headerlink" title="23.3.1 基本快捷键"></a>23.3.1 基本快捷键</h3><ul>
<li><p>F11文本高亮标记</p>
</li>
<li><p>Ctrl+N查找类</p>
</li>
<li><p>Ctrl+Alt+Shift+N查找方法或全局变量</p>
</li>
<li><p>Ctrl+Shift+N查找文件</p>
</li>
<li><p>Ctrl[+Alt]+Space获取静态常量或方法建议</p>
</li>
<li><p>Ctrl+W选取内容</p>
</li>
<li><p>在语句开头按Ctrl+W选取关键字对应语句，例如if语句</p>
</li>
<li><p>复制删除：Ctrl+D复制行  Ctrl+X剪切行     Ctrl+Y删除行</p>
</li>
<li><p>Alt+Shift+↑↓移动行</p>
</li>
<li><p>Ctrl+Shift+↑↓移动方法</p>
</li>
<li><p>环绕和解开：Ctrl+Alt+T   Ctrl+Shift+Delete</p>
</li>
<li><p>多选：Alt+J选择 Alt+Shift+J取消一项  Ctrl+Alt+Shift+J选择文中所有匹配项</p>
</li>
<li><p>Ctrl+F12文件结构&#x2F;&#x2F;可查看具体类定义随后Alt+7展开结构方法</p>
</li>
</ul>
<h3 id="23-3-2-补全"><a href="#23-3-2-补全" class="headerlink" title="23.3.2 补全"></a>23.3.2 补全</h3><ul>
<li><p>Ctrl+Shift+Space类型匹配补全</p>
</li>
<li><p>.后缀补全</p>
</li>
<li><p>Ctrl+Space基本补全词条</p>
</li>
<li><p>Ctrl+Shift+Enter补全语句</p>
</li>
<li><p>Alt+Enter意图补全</p>
</li>
<li><p>Tab补全，使用Ctrl+Space查看补全建议，选择使用Tab进行补全</p>
</li>
</ul>
<h3 id="23-3-3-重构"><a href="#23-3-3-重构" class="headerlink" title="23.3.3 重构"></a>23.3.3 重构</h3><ul>
<li><p>Shift+F6重命名</p>
</li>
<li><p>Ctrl+Alt+V提取变量集体更名</p>
</li>
<li><p>Ctrl+Alt+Shift+T重构部分列表</p>
</li>
<li><p>Alt + Insert快捷插入</p>
</li>
</ul>
<h3 id="23-3-4-代码辅助"><a href="#23-3-4-代码辅助" class="headerlink" title="23.3.4 代码辅助"></a>23.3.4 代码辅助</h3><ul>
<li><p>本地历史记录恢复撤销无法恢复的删除内容</p>
</li>
<li><p>Ctrl+Alt+L格式化代码</p>
</li>
<li><p>Ctrl+P形参信息，可以获取形参列表的内容</p>
</li>
<li><p>Ctrl+Q预览光标处文档，可以看到形参内容等信息</p>
</li>
<li><p>Ctrl+Shift+I查看文本光标处符号的定义，可以看到方法全部内容</p>
</li>
<li><p>Ctrl+F12显示本类所有方法</p>
</li>
<li><p>Ctrl+H显示本类所有实现类</p>
</li>
</ul>
<h3 id="23-3-5-编码辅助"><a href="#23-3-5-编码辅助" class="headerlink" title="23.3.5 编码辅助"></a>23.3.5 编码辅助</h3><ul>
<li><p>F2跳转高亮错误</p>
</li>
<li><p>Ctrl+F1获得简要说明信息，可以获取方法帮助</p>
</li>
</ul>
<h2 id="23-4-快捷模板学习"><a href="#23-4-快捷模板学习" class="headerlink" title="23.4 快捷模板学习"></a>23.4 快捷模板学习</h2><ul>
<li><p>Editor-&gt;Posfix Completion</p>
</li>
<li><p>Editor-&gt;Live Templates</p>
</li>
</ul>
<p>可以自定义模板进行减少代码量</p>
<h1 id="二十四、扩展工具"><a href="#二十四、扩展工具" class="headerlink" title="二十四、扩展工具"></a>二十四、扩展工具</h1><h2 id="24-1-Lombok"><a href="#24-1-Lombok" class="headerlink" title="24.1 @Lombok"></a>24.1 @Lombok</h2><ul>
<li><p>@Accessors(chain&#x3D;true) 是 Lombok 中的一个注解，它可以通过链式调用的方式来简化 Java 对象的构建和操作。</p>
</li>
<li><p>@Accessors(chain&#x3D;true) 可以自动为 Java 类中的 setter 方法返回当前对象的实例，从而实现链式调用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>().setName(<span class="string">&quot;Alice&quot;</span>).setAge(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://blog.dragonbamboo.com">Bamboo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://blog.dragonbamboo.com/2023/08/31/java/">http://blog.dragonbamboo.com/2023/08/31/java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.dragonbamboo.com" target="_blank">竹间小客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/img/ava.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/31/%E4%B9%B1%E7%A0%81/" title="乱码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">乱码</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/31/dubbo/" title="dubbo"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">dubbo</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/30/springcloud/" title="springcloud"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">springcloud</div></div></a></div><div><a href="/2023/08/31/%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="部署服务器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-31</div><div class="title">部署服务器</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Bamboo</div><div class="author-info__description">所有随风而逝的都是属于昨天的，所有历经风雨留下来的才是面向未来的。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dragonBamboo"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的竹间小客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%86%85%E5%AD%98"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-DOS%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.2 DOS命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%BC%96%E8%AF%91"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 编译</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">二、基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%B3%A8%E9%87%8A"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 引用数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A7%84%E5%88%99"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 数据类型规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-UTF-8%E7%BC%96%E7%A0%81"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4 UTF-8编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.3.5 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">① 自动类型提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">② 强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-6-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.6.</span> <span class="toc-text">2.3.6 进制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.7.</span> <span class="toc-text">2.3.7运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 程序流程控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">三、数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">四、常见算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">五、内存结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1OOP"><span class="toc-number">6.</span> <span class="toc-text">六、面向对象OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%BB%86%E8%B0%88%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 细谈方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E9%80%92%E5%BD%92recursion"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 递归recursion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%B0%81%E8%A3%85%E5%92%8C%E9%9A%90%E8%97%8F"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 封装和隐藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E7%BB%A7%E6%89%BFextends"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 继承extends</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%E5%A4%9A%E6%80%81"><span class="toc-number">6.5.</span> <span class="toc-text">6.5多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 访问权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-JavaBean"><span class="toc-number">6.7.</span> <span class="toc-text">6.7 JavaBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">6.8.</span> <span class="toc-text">6.8 包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.9.</span> <span class="toc-text">6.9 this关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.10.</span> <span class="toc-text">6.10 super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11-package-import%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.11.</span> <span class="toc-text">6.11 package import关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-12-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.12.</span> <span class="toc-text">6.12 final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-13-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.13.</span> <span class="toc-text">6.13 static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-14-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">6.14.</span> <span class="toc-text">6.14 代码块{}</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-15-MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.15.</span> <span class="toc-text">6.15 MVC设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-16-abstract-%E6%8A%BD%E8%B1%A1"><span class="toc-number">6.16.</span> <span class="toc-text">6.16 abstract(抽象)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-17-interface-%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.17.</span> <span class="toc-text">6.17 interface(接口)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-18-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">6.18.</span> <span class="toc-text">6.18 内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-19-%E6%9E%9A%E4%B8%BE%E7%B1%BBenum"><span class="toc-number">6.19.</span> <span class="toc-text">6.19 枚举类enum</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81JUnit4"><span class="toc-number">7.</span> <span class="toc-text">七、JUnit4</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81Annotation%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">八、Annotation注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%B8%B8%E7%94%A8Annotation"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 常用Annotation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3"><span class="toc-number">8.1.1.</span> <span class="toc-text">8.1.1 文档相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E7%BC%96%E8%AF%91%E6%97%B6%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5"><span class="toc-number">8.1.2.</span> <span class="toc-text">8.1.2 编译时格式检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-3-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.1.3.</span> <span class="toc-text">8.1.3 注解的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.1.4.</span> <span class="toc-text">8.1.4 自定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-5-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.1.5.</span> <span class="toc-text">8.1.5 元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-6-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.1.6.</span> <span class="toc-text">8.1.6 反射获取注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-7-JDK8%E6%96%B0%E5%A2%9E%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.1.7.</span> <span class="toc-text">8.1.7 JDK8新增可重复注解，类型注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">九、设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-singleton"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 单例模式(singleton)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.1.1.</span> <span class="toc-text">9.1.1 饿汉模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F-%E5%BB%B6%E8%BF%9F%E6%9E%84%E9%80%A0"><span class="toc-number">9.1.2.</span> <span class="toc-text">9.1.2 懒汉模式(延迟构造)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-TemplateMethod"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 模板方法模式(TemplateMethod)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 代理模式(Proxy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Factory"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 工厂设计模式(Factory)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81classpath%E8%AF%B4%E6%98%8E"><span class="toc-number">10.</span> <span class="toc-text">十、classpath说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86Exception"><span class="toc-number">11.</span> <span class="toc-text">十一、异常处理Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-Error"><span class="toc-number">11.1.</span> <span class="toc-text">11.1 Error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-Exception"><span class="toc-number">11.2.</span> <span class="toc-text">11.2 Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-RuntimeException"><span class="toc-number">11.2.1.</span> <span class="toc-text">11.2.1 RuntimeException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-%E7%BC%96%E8%AF%91%E6%97%B6javac%E5%BC%82%E5%B8%B8"><span class="toc-number">11.2.2.</span> <span class="toc-text">11.2.2 编译时javac异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">11.2.3.</span> <span class="toc-text">11.2.3 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-4-finally"><span class="toc-number">11.2.4.</span> <span class="toc-text">11.2.4 finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-5-throws"><span class="toc-number">11.2.5.</span> <span class="toc-text">11.2.5 throws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-6-throw"><span class="toc-number">11.2.6.</span> <span class="toc-text">11.2.6 throw</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-7-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">11.2.7.</span> <span class="toc-text">11.2.7 自定义异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">十二、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">12.1.</span> <span class="toc-text">12.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">12.2 线程的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-Thread"><span class="toc-number">12.3.</span> <span class="toc-text">12.3 Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">12.3.1.</span> <span class="toc-text">12.3.1 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">12.3.2.</span> <span class="toc-text">12.3.2 构造器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">12.4.</span> <span class="toc-text">12.4 线程优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">12.5.</span> <span class="toc-text">12.5 线程的创建与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-1-%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="toc-number">12.5.1.</span> <span class="toc-text">12.5.1 方式一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-2-%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-number">12.5.2.</span> <span class="toc-text">12.5.2 方式二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-3-%E6%96%B9%E5%BC%8F%E4%B8%89"><span class="toc-number">12.5.3.</span> <span class="toc-text">12.5.3 方式三</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.5.3.1.</span> <span class="toc-text">① Callable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-Future%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.5.3.2.</span> <span class="toc-text">② Future接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.5.3.3.</span> <span class="toc-text">③ 实现线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-6-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">12.6.</span> <span class="toc-text">12.6 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-1-ExecutorService"><span class="toc-number">12.6.1.</span> <span class="toc-text">12.6.1 ExecutorService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-2-Executors"><span class="toc-number">12.6.2.</span> <span class="toc-text">12.6.2 Executors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">12.6.2.1.</span> <span class="toc-text">① 线程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.6.2.2.</span> <span class="toc-text">② 实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">12.7.</span> <span class="toc-text">12.7 线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-8-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">12.8.</span> <span class="toc-text">12.8 线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-8-1-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">12.8.1.</span> <span class="toc-text">12.8.1 同步代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E8%AF%B4%E6%98%8E"><span class="toc-number">12.8.1.1.</span> <span class="toc-text">① 说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E5%90%8C%E6%AD%A5%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">12.8.1.2.</span> <span class="toc-text">② 同步监视器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E5%90%8C%E6%AD%A5%E7%9B%91%E8%A7%86%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">12.8.1.3.</span> <span class="toc-text">③ 同步监视器的创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-8-2-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">12.8.2.</span> <span class="toc-text">12.8.2 同步方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-9-%E6%AD%BB%E9%94%81"><span class="toc-number">12.9.</span> <span class="toc-text">12.9 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-9-1-%E6%AD%BB%E9%94%81%E6%BC%94%E7%A4%BA"><span class="toc-number">12.9.1.</span> <span class="toc-text">12.9.1 死锁演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-9-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">12.9.2.</span> <span class="toc-text">12.9.2 解决方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-10-Lock-%E9%94%81"><span class="toc-number">12.10.</span> <span class="toc-text">12.10 Lock(锁)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-11-synchronized%E4%B8%8ELock"><span class="toc-number">12.11.</span> <span class="toc-text">12.11 synchronized与Lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-12-sleep%E4%B8%8Ewait"><span class="toc-number">12.12.</span> <span class="toc-text">12.12 sleep与wait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-13-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">12.13.</span> <span class="toc-text">12.13 线程通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81API-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">13.</span> <span class="toc-text">十三、API(常用类)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-Scanner"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 Scanner</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-String"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-1-%E4%B8%A4%E7%A7%8D%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F"><span class="toc-number">13.2.1.</span> <span class="toc-text">13.2.1 两种赋值方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-2-new-String"><span class="toc-number">13.2.2.</span> <span class="toc-text">13.2.2 new String()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">13.2.3.</span> <span class="toc-text">13.2.3 字符串常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-4-%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">13.2.4.</span> <span class="toc-text">13.2.4 值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-5-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.5.</span> <span class="toc-text">13.2.5 常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-StringBuffer-StringBuilder"><span class="toc-number">13.3.</span> <span class="toc-text">13.3 StringBuffer StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-1-StringBuffer%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97"><span class="toc-number">13.3.1.</span> <span class="toc-text">13.3.1 StringBuffer可变字符序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-2-StringBuilder%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E5%BA%8F%E5%88%97"><span class="toc-number">13.3.2.</span> <span class="toc-text">13.3.2 StringBuilder可变字符序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.3.</span> <span class="toc-text">13.3.3 常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-Math"><span class="toc-number">13.4.</span> <span class="toc-text">13.4 Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-BigInteger%E5%92%8CBigDecimal"><span class="toc-number">13.5.</span> <span class="toc-text">13.5 BigInteger和BigDecimal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-Random"><span class="toc-number">13.6.</span> <span class="toc-text">13.6 Random</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-Arrays"><span class="toc-number">13.7.</span> <span class="toc-text">13.7 Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-8-System"><span class="toc-number">13.8.</span> <span class="toc-text">13.8 System</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-9-TIME"><span class="toc-number">13.9.</span> <span class="toc-text">13.9 TIME</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-1-System"><span class="toc-number">13.9.1.</span> <span class="toc-text">13.9.1 System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-2-Date"><span class="toc-number">13.9.2.</span> <span class="toc-text">13.9.2 Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-3-SimpleDateFormat"><span class="toc-number">13.9.3.</span> <span class="toc-text">13.9.3 SimpleDateFormat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-4-Calendar%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="toc-number">13.9.4.</span> <span class="toc-text">13.9.4 Calendar日历类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-5-JDK8%E5%89%8D%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">13.9.5.</span> <span class="toc-text">13.9.5 JDK8前面临的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-6-LocalDate-LocalTime-LocalDateTime"><span class="toc-number">13.9.6.</span> <span class="toc-text">13.9.6 LocalDate LocalTime LocalDateTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-7-Instant-%E7%9E%AC%E6%97%B6"><span class="toc-number">13.9.7.</span> <span class="toc-text">13.9.7 Instant 瞬时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-8-DateTimeFormatter"><span class="toc-number">13.9.8.</span> <span class="toc-text">13.9.8 DateTimeFormatter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-10-Object"><span class="toc-number">13.10.</span> <span class="toc-text">13.10 Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-11-%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">13.11.</span> <span class="toc-text">13.11 比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-11-1-Comparable%E6%8E%A5%E5%8F%A3-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">13.11.1.</span> <span class="toc-text">13.11.1 Comparable接口(自然排序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-11-2-Comparator%E6%8E%A5%E5%8F%A3-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">13.11.2.</span> <span class="toc-text">13.11.2 Comparator接口(定制排序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-11-3-%E5%AF%B9%E6%AF%94"><span class="toc-number">13.11.3.</span> <span class="toc-text">13.11.3 对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-11-4-%E6%AF%94%E8%BE%83%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.11.4.</span> <span class="toc-text">13.11.4 比较器实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88"><span class="toc-number">14.</span> <span class="toc-text">十四、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">14.1.</span> <span class="toc-text">14.1 数组与集合的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E6%A6%82%E8%BF%B0"><span class="toc-number">14.2.</span> <span class="toc-text">14.2 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E5%85%B3%E7%B3%BB"><span class="toc-number">14.3.</span> <span class="toc-text">14.3 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.4.</span> <span class="toc-text">14.4 Collection接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5-List%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.5.</span> <span class="toc-text">14.5 List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">14.5.1.</span> <span class="toc-text">14.5.1 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-2-ArrayList"><span class="toc-number">14.5.2.</span> <span class="toc-text">14.5.2 ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E5%BE%AA%E7%8E%AF"><span class="toc-number">14.5.2.1.</span> <span class="toc-text">① 循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-3-LinkedList"><span class="toc-number">14.5.3.</span> <span class="toc-text">14.5.3 LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-4-Vector"><span class="toc-number">14.5.4.</span> <span class="toc-text">14.5.4 Vector</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-6-Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.6.</span> <span class="toc-text">14.6 Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">14.6.1.</span> <span class="toc-text">14.6.1 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-2-%E6%97%A0%E5%BA%8F%E6%80%A7%E8%AF%B4%E6%98%8E"><span class="toc-number">14.6.2.</span> <span class="toc-text">14.6.2 无序性说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-3-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E8%AF%B4%E6%98%8E"><span class="toc-number">14.6.3.</span> <span class="toc-text">14.6.3 不可重复性说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-4-hashCode-%E4%B8%8E-equals"><span class="toc-number">14.6.4.</span> <span class="toc-text">14.6.4 hashCode 与 equals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-5-HashSet"><span class="toc-number">14.6.5.</span> <span class="toc-text">14.6.5 HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-6-LinkedHashSet"><span class="toc-number">14.6.6.</span> <span class="toc-text">14.6.6 LinkedHashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-7-TreeSet"><span class="toc-number">14.6.7.</span> <span class="toc-text">14.6.7 TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E7%89%B9%E6%80%A7"><span class="toc-number">14.6.7.1.</span> <span class="toc-text">① 特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">14.6.7.2.</span> <span class="toc-text">② 底层结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">14.6.7.3.</span> <span class="toc-text">③ 自然排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">14.6.7.4.</span> <span class="toc-text">④ 定制排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-7-Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.7.</span> <span class="toc-text">14.7 Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">14.7.1.</span> <span class="toc-text">14.7.1 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-2-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">14.7.2.</span> <span class="toc-text">14.7.2 底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-3-key%E4%B8%8Evalue"><span class="toc-number">14.7.3.</span> <span class="toc-text">14.7.3 key与value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-4-LinkedHashMap"><span class="toc-number">14.7.4.</span> <span class="toc-text">14.7.4 LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-5-TreeMap"><span class="toc-number">14.7.5.</span> <span class="toc-text">14.7.5 TreeMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-8-Properties"><span class="toc-number">14.8.</span> <span class="toc-text">14.8 Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-9-Iterator%E9%81%8D%E5%8E%86"><span class="toc-number">14.9.</span> <span class="toc-text">14.9 Iterator遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-10-Foreach%E9%81%8D%E5%8E%86"><span class="toc-number">14.10.</span> <span class="toc-text">14.10 Foreach遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-11-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">14.11.</span> <span class="toc-text">14.11 Collections工具类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E6%B3%9B%E5%9E%8BGeneric"><span class="toc-number">15.</span> <span class="toc-text">十五、泛型Generic</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81DAO"><span class="toc-number">16.</span> <span class="toc-text">十六、DAO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81IO%E6%B5%81"><span class="toc-number">17.</span> <span class="toc-text">十七、IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-File"><span class="toc-number">17.1.</span> <span class="toc-text">17.1 File</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">17.1.1.</span> <span class="toc-text">17.1.1 常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-%E6%B5%81"><span class="toc-number">17.2.</span> <span class="toc-text">17.2 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-1-%E5%85%B3%E9%97%AD%E6%B5%81"><span class="toc-number">17.2.1.</span> <span class="toc-text">17.2.1 关闭流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">17.3.</span> <span class="toc-text">17.3 字节字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-1-FileInputStream"><span class="toc-number">17.3.1.</span> <span class="toc-text">17.3.1 FileInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-2-FileOutputStream"><span class="toc-number">17.3.2.</span> <span class="toc-text">17.3.2 FileOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-3-FileReader"><span class="toc-number">17.3.3.</span> <span class="toc-text">17.3.3 FileReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-4-FileWriter"><span class="toc-number">17.3.4.</span> <span class="toc-text">17.3.4 FileWriter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-4-%E5%AD%97%E7%AC%A6%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">17.4.</span> <span class="toc-text">17.4 字符字节缓冲流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-5-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">17.5.</span> <span class="toc-text">17.5 转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-5-1-InputStreamReader%E8%A7%A3%E7%A0%81"><span class="toc-number">17.5.1.</span> <span class="toc-text">17.5.1 InputStreamReader解码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-5-2-OutputStreamWriter%E7%BC%96%E7%A0%81"><span class="toc-number">17.5.2.</span> <span class="toc-text">17.5.2 OutputStreamWriter编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-6-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">17.6.</span> <span class="toc-text">17.6 标准输入输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-7-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">17.7.</span> <span class="toc-text">17.7 打印流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-8-%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">17.8.</span> <span class="toc-text">17.8 数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-8-1-DataInputStream"><span class="toc-number">17.8.1.</span> <span class="toc-text">17.8.1 DataInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-8-2-DataOutputStream"><span class="toc-number">17.8.2.</span> <span class="toc-text">17.8.2 DataOutputStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-9-%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">17.9.</span> <span class="toc-text">17.9 对象流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-9-1-%E5%AE%9E%E7%8E%B0Serializable%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.9.1.</span> <span class="toc-text">17.9.1 实现Serializable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-9-2-%E7%B1%BB%E4%BD%93%E5%A3%B0%E6%98%8E%E5%BA%8F%E5%88%97%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-number">17.9.2.</span> <span class="toc-text">17.9.2 类体声明序列化版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-9-3-%E7%89%B9%E5%88%AB"><span class="toc-number">17.9.3.</span> <span class="toc-text">17.9.3 特别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-9-4-ObjectOutputStream"><span class="toc-number">17.9.4.</span> <span class="toc-text">17.9.4 ObjectOutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-9-5-ObjectInputStream"><span class="toc-number">17.9.5.</span> <span class="toc-text">17.9.5 ObjectInputStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-10-RandomAccessFile"><span class="toc-number">17.10.</span> <span class="toc-text">17.10 RandomAccessFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-10-7-mode"><span class="toc-number">17.10.1.</span> <span class="toc-text">17.10.7 mode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-10-8-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">17.10.2.</span> <span class="toc-text">17.10.8 常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-11-ByteArrayOutputStream"><span class="toc-number">17.11.</span> <span class="toc-text">17.11 ByteArrayOutputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-12-NIO-2"><span class="toc-number">17.12.</span> <span class="toc-text">17.12 NIO.2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-12-1-Path"><span class="toc-number">17.12.1.</span> <span class="toc-text">17.12.1 Path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-12-2-Paths"><span class="toc-number">17.12.2.</span> <span class="toc-text">17.12.2 Paths</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-13-apach-commons-io"><span class="toc-number">17.13.</span> <span class="toc-text">17.13 apach-commons-io</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-13-1-FileUtils"><span class="toc-number">17.13.1.</span> <span class="toc-text">17.13.1 FileUtils</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AB%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BSocket"><span class="toc-number">18.</span> <span class="toc-text">十八、网络编程Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1-IP%E5%88%86%E4%B8%BAIPv4%E5%92%8CIPv6"><span class="toc-number">18.1.</span> <span class="toc-text">18.1 IP分为IPv4和IPv6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-2-%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">18.2.</span> <span class="toc-text">18.2 端口号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-3-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">18.3.</span> <span class="toc-text">18.3 网络通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-1-TCP"><span class="toc-number">18.3.1.</span> <span class="toc-text">18.3.1 TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-2-UDP"><span class="toc-number">18.3.2.</span> <span class="toc-text">18.3.2 UDP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-4-InetAddress"><span class="toc-number">18.4.</span> <span class="toc-text">18.4 InetAddress</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">18.4.1.</span> <span class="toc-text">18.4.1 常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-5-Socket%EF%BC%9ATCP"><span class="toc-number">18.5.</span> <span class="toc-text">18.5 Socket：TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">18.5.1.</span> <span class="toc-text">18.5.1 常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-6-TCP%E9%80%9A%E4%BF%A1"><span class="toc-number">18.6.</span> <span class="toc-text">18.6 TCP通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-7-DatagramSocket%EF%BC%9AUDP"><span class="toc-number">18.7.</span> <span class="toc-text">18.7 DatagramSocket：UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-8-URL"><span class="toc-number">18.8.</span> <span class="toc-text">18.8 URL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-8-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">18.8.1.</span> <span class="toc-text">18.8.1 常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">19.</span> <span class="toc-text">十九、反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#19-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">19.1.</span> <span class="toc-text">19.1 常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-2-%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">19.2.</span> <span class="toc-text">19.2 使用条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-3-Class%E7%90%86%E8%A7%A3"><span class="toc-number">19.3.</span> <span class="toc-text">19.3 Class理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-4-%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B"><span class="toc-number">19.4.</span> <span class="toc-text">19.4 获取Class实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-5-%E8%8E%B7%E5%8F%96Class%E5%B1%9E%E6%80%A7"><span class="toc-number">19.5.</span> <span class="toc-text">19.5 获取Class属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5-1-%E4%BD%BF%E7%94%A8Declared%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">19.5.1.</span> <span class="toc-text">19.5.1 使用Declared修饰的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5-2-Field%EF%BC%9A%E5%B1%9E%E6%80%A7"><span class="toc-number">19.5.2.</span> <span class="toc-text">19.5.2 Field：属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5-3-Method%EF%BC%9A%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">19.5.3.</span> <span class="toc-text">19.5.3 Method：方法名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5-4-Constructor%EF%BC%9A%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">19.5.4.</span> <span class="toc-text">19.5.4 Constructor：构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5-5-Superclass%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E7%88%B6%E7%B1%BB"><span class="toc-number">19.5.5.</span> <span class="toc-text">19.5.5 Superclass：运行时父类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5-6-Interface%EF%BC%9A%E6%8E%A5%E5%8F%A3"><span class="toc-number">19.5.6.</span> <span class="toc-text">19.5.6 Interface：接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5-7-Package%EF%BC%9A%E5%8C%85"><span class="toc-number">19.5.7.</span> <span class="toc-text">19.5.7 Package：包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-6-%E8%AE%BE%E7%BD%AE"><span class="toc-number">19.6.</span> <span class="toc-text">19.6 设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-7-%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">19.7.</span> <span class="toc-text">19.7 创建运行时类的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-8-%E5%8F%AF%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">19.8.</span> <span class="toc-text">19.8 可获取Class实例的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-9-ClassLoader%E8%AF%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">19.9.</span> <span class="toc-text">19.9 ClassLoader读配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-10-%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">19.10.</span> <span class="toc-text">19.10 反射应用：动态代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E3%80%81JDK8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">20.</span> <span class="toc-text">二十、JDK8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#20-1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">20.1.</span> <span class="toc-text">20.1 Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">20.2.</span> <span class="toc-text">20.2 函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-1-%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">20.2.1.</span> <span class="toc-text">20.2.1 内置四大核心函数式接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">20.3.</span> <span class="toc-text">20.3 方法引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-4-Stream-API"><span class="toc-number">20.4.</span> <span class="toc-text">20.4 Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-4-1-%E6%B3%A8"><span class="toc-number">20.4.1.</span> <span class="toc-text">20.4.1 注</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-4-2-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">20.4.2.</span> <span class="toc-text">20.4.2 使用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-4-3-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">20.4.3.</span> <span class="toc-text">20.4.3 创建方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-4-4-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">20.4.4.</span> <span class="toc-text">20.4.4 中间操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E7%AD%9B%E9%80%89%E4%B8%8E%E5%88%87%E7%89%87"><span class="toc-number">20.4.4.1.</span> <span class="toc-text">① 筛选与切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E6%98%A0%E5%B0%84"><span class="toc-number">20.4.4.2.</span> <span class="toc-text">② 映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E6%8E%92%E5%BA%8F"><span class="toc-number">20.4.4.3.</span> <span class="toc-text">③ 排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-4-5-%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">20.4.5.</span> <span class="toc-text">20.4.5 终止操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE"><span class="toc-number">20.4.5.1.</span> <span class="toc-text">① 匹配与查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E5%BD%92%E7%BA%A6"><span class="toc-number">20.4.5.2.</span> <span class="toc-text">② 归约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E6%94%B6%E9%9B%86"><span class="toc-number">20.4.5.3.</span> <span class="toc-text">③ 收集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-5-Optional"><span class="toc-number">20.5.</span> <span class="toc-text">20.5 Optional</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-1-%E5%88%9B%E5%BB%BAOptional%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">20.5.1.</span> <span class="toc-text">20.5.1 创建Optional类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-2-%E5%88%A4%E6%96%ADOptional%E5%AE%B9%E5%99%A8"><span class="toc-number">20.5.2.</span> <span class="toc-text">20.5.2 判断Optional容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-3-%E8%8E%B7%E5%8F%96Optional%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">20.5.3.</span> <span class="toc-text">20.5.3 获取Optional容器的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-4-%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81-NullPointerException"><span class="toc-number">20.5.4.</span> <span class="toc-text">20.5.4 优化代码,NullPointerException</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81JDK9"><span class="toc-number">21.</span> <span class="toc-text">二十一、JDK9</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E5%B0%8FTips"><span class="toc-number">22.</span> <span class="toc-text">二十二、小Tips</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81IDEA"><span class="toc-number">23.</span> <span class="toc-text">二十三、IDEA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-1-%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE"><span class="toc-number">23.1.</span> <span class="toc-text">23.1 基本设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-1-idea-properties"><span class="toc-number">23.1.1.</span> <span class="toc-text">23.1 idea.properties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-plugins"><span class="toc-number">23.2.</span> <span class="toc-text">23.2 plugins</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Auto-filling-Java-call-arguments"><span class="toc-number">23.2.1.</span> <span class="toc-text">Auto filling Java call arguments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven-Helper"><span class="toc-number">23.2.2.</span> <span class="toc-text">Maven Helper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatisCodeHelperPro"><span class="toc-number">23.2.3.</span> <span class="toc-text">MyBatisCodeHelperPro</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Free-MyBatis-plugin"><span class="toc-number">23.2.4.</span> <span class="toc-text">Free MyBatis plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Alibaba-Java-Coding-Guidelines"><span class="toc-number">23.2.5.</span> <span class="toc-text">Alibaba Java Coding Guidelines</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeGlance"><span class="toc-number">23.2.6.</span> <span class="toc-text">CodeGlance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rainbow-Brackets"><span class="toc-number">23.2.7.</span> <span class="toc-text">Rainbow Brackets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Translation"><span class="toc-number">23.2.8.</span> <span class="toc-text">Translation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#One-Dark-theme"><span class="toc-number">23.2.9.</span> <span class="toc-text">One Dark theme</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atom-Material-Icons"><span class="toc-number">23.2.10.</span> <span class="toc-text">Atom_Material_Icons</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-3-%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">23.3.</span> <span class="toc-text">23.3 快捷键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-1-%E5%9F%BA%E6%9C%AC%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">23.3.1.</span> <span class="toc-text">23.3.1 基本快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-2-%E8%A1%A5%E5%85%A8"><span class="toc-number">23.3.2.</span> <span class="toc-text">23.3.2 补全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-3-%E9%87%8D%E6%9E%84"><span class="toc-number">23.3.3.</span> <span class="toc-text">23.3.3 重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-4-%E4%BB%A3%E7%A0%81%E8%BE%85%E5%8A%A9"><span class="toc-number">23.3.4.</span> <span class="toc-text">23.3.4 代码辅助</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-5-%E7%BC%96%E7%A0%81%E8%BE%85%E5%8A%A9"><span class="toc-number">23.3.5.</span> <span class="toc-text">23.3.5 编码辅助</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-%E5%BF%AB%E6%8D%B7%E6%A8%A1%E6%9D%BF%E5%AD%A6%E4%B9%A0"><span class="toc-number">23.4.</span> <span class="toc-text">23.4 快捷模板学习</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81%E6%89%A9%E5%B1%95%E5%B7%A5%E5%85%B7"><span class="toc-number">24.</span> <span class="toc-text">二十四、扩展工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#24-1-Lombok"><span class="toc-number">24.1.</span> <span class="toc-text">24.1 @Lombok</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/31/html-css/" title="html+css">html+css</a><time datetime="2023-08-31T11:40:27.000Z" title="发表于 2023-08-31 19:40:27">2023-08-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/31/urllib/" title="urllib">urllib</a><time datetime="2023-08-31T06:19:19.000Z" title="发表于 2023-08-31 14:19:19">2023-08-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/31/selenium/" title="selenium">selenium</a><time datetime="2023-08-31T06:18:40.000Z" title="发表于 2023-08-31 14:18:40">2023-08-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/31/scrapy/" title="scrapy">scrapy</a><time datetime="2023-08-31T06:17:18.000Z" title="发表于 2023-08-31 14:17:18">2023-08-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/31/requests/" title="requests">requests</a><time datetime="2023-08-31T06:16:27.000Z" title="发表于 2023-08-31 14:16:27">2023-08-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Bamboo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    const close = () => {
      Chatra('minimizeWidget')
      Chatra('hide')
    }

    const open = () => {
      Chatra('openChat', true)
      Chatra('show')
    }

    window.ChatraSetup = {
      startHidden: true
    }
  
    window.chatBtnFn = () => {
      const isShow = document.getElementById('chatra').classList.contains('chatra--expanded')
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        Chatra('hide')
      },
      show: () => {
        Chatra('show')
      }
    }
  }

  (function(d, w, c) {
    w.ChatraID = 'mBkDBN8SKJcbca8bm'
    var s = d.createElement('script')
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments)
    }
    s.async = true
    s.src = 'https://call.chatra.io/chatra.js'
    if (d.head) d.head.appendChild(s)
  })(document, window, 'Chatra')

})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>